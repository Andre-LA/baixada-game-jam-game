## local make_optional = generalize(function(T)
   local T = @#[T]#

   local OptionalT <codename #['Optional_'..T.codename]#> = @record{
      value: T,
      filled: boolean
   }

   ## OptionalT.value.is_optional = true
   ## OptionalT.value.subtype = T

   function OptionalT:get(): T
      assert(self.filled, "optional value has no value")
      return self.value
   end

   function OptionalT:set(v: T)
      self.value = v
      self.filled = true
   end

   function OptionalT:clear()
      self.value = (@T)()
      self.filled = false
   end

   ## return OptionalT
## end)

global optional: type = #[make_optional]#

## if TEST then
   require 'string'

   local ok_color: string = string.char(27) .. '[' .. tostring(32) .. 'm'
   local err_color: string = string.char(27) .. '[' .. tostring(31) .. 'm'
   local reset_color: string = string.char(27) .. '[' .. tostring(0) .. 'm'

   local function _assert(cnd: boolean, msg: string)
      local final_msg: stringview = err_color .. msg
      assert(cnd, final_msg)
   end

   local R = @record{v: integer}
   local optR: optional(R);

   _assert(not optR.filled, "test error: optR is marked as filled, but it's with no value")

   local r = (@R){v = 123}
   optR:set(r)

   _assert(optR.filled, "test error: optR is marked as not filled, but it's with value")
   _assert(optR:get().v == r.v and optR.value.v == r.v, "test error: optR's value is diffent from original value")

   local x: optional(uinteger)

   _assert(x.value == 0 and not x.filled, 'test error: x should be {value = 0, filled = false}')

   x:set(10)

   _assert(x.value == 10 and x.filled, 'test error: x should be {value = 10, filled = true}')
   _assert(x.value == x:get(), "test error: x:get() should returns the x's value")

   print (ok_color .. 'optional test: ok' .. reset_color)
## end
