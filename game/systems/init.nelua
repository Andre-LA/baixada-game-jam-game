require 'math'
require 'vector'
require 'raylib'
require 'rotor'
require 'game.components'

global System = @record{
   read: vector(BitsetArray),
   write: vector(BitsetArray),
   system_data: SystemData
}

-- [ systems [
global SpritePainter = @record{
   system: System
}

function SpritePainter.new(): SpritePainter
   local new_system: SpritePainter = {
      system = {
         read = {bitset_array.copy(component_masks.sprite), bitset_array.copy(component_masks.position)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function SpritePainter:run(sprite_storage: Storage(Sprite)*, position_storage: Storage(Position)*)
   local sys_len = #self.system.system_data.components_indexes

   local draw_order: vector(uinteger) = {}
   draw_order:reserve(sys_len)

   local y_vec: vector(float32) = {}
   y_vec:reserve(sys_len)

   for i = 0, < sys_len do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = sprite_storage:get_entry(sprite_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local position = opt_position:get()

            if  #draw_order == 0 then
               y_vec:push(position.position.y)
               draw_order:push(i)
            else
               local inserted = false
               for j = 0, < #draw_order do
                  if position.position.y < y_vec[j] then
                     y_vec:insert(j, position.position.y)
                     draw_order:insert(j, i)
                     inserted = true
                     break
                  end
               end
               if not inserted then
                  y_vec:push(position.position.y)
                  draw_order:push(i)
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end

   for i = 0, < sys_len do
      local ids = self.system.system_data.components_indexes[ draw_order[i] ]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = sprite_storage:get_entry(sprite_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local sprite = opt_sprite:get()
            if sprite.visible then
               local position = opt_position:get()

               local img_unit_w: integer = sprite.sprite_sheet.width // sprite.frame_rect.width
               local img_unit_h: integer = sprite.sprite_sheet.height // sprite.frame_rect.height

               sprite.frame_rect.x = (sprite.frame_index % img_unit_w) * sprite.frame_rect.width
               sprite.frame_rect.y = (sprite.frame_index // img_unit_w) * sprite.frame_rect.height

               Raylib.DrawTextureRec(sprite.sprite_sheet, sprite.frame_rect, position.position + sprite.offset, WHITE)
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

## local make_system = generalize(function(T, run_type, opt_T_coll, ...)
   ##[[
      local function union(a,b)
         local t={}
         for i=1,#a do t[#t+1]=a[i] end
         for i=1,#b do t[#t+1]=b[i] end
         return t
      end

      local args = {...}
      local qtd_read = args[1]
      local w_argpos = 2 + qtd_read*2
      local qtd_write = args[w_argpos]

      local read_names = {}
      local read_types = {}
      for i = 2, 1 + qtd_read do
         table.insert(read_names, args[i])
      end

      for i = 2 + qtd_read, qtd_read * 2 + 1 do
         table.insert(read_types, args[i])
      end

      local write_names = {}
      local write_types = {}

      for i = w_argpos + 1, w_argpos + qtd_write do
         table.insert(write_names, args[i])
      end

      for i = w_argpos + qtd_write + 1, #args do
         table.insert(write_types, args[i])
      end

      staticassert(traits.is_type(T), "invalid type %s", T)
      staticassert(#read_names == #read_types, "quantity of read names and read types doesn't match")
      staticassert(#write_names == #write_types, "quantity of write names and write types doesn't match")

      local component_names = union(read_names, write_names)
      local component_types = union(read_types, write_types)
   ]]

   local T = @#[T]#
   local optCollectionT = @#[opt_T_coll]#

   -- TODO: generate collections on make_system
   --local optCollectionT = @record{}

   --## for i = 1, #component_names do
      --## local comp_name, comp_type = component_names[i], component_types[i]
      --## print(type(comp_name), comp_name)
      --## print(type(comp_type), comp_type)

      --local optTi: type = @#|comp_type|#

      --## print(type(optTi), optTi)

      --## optCollectionT.value:add_field(comp_name, optTi)
   --## end

   local systemT <nickname #[string.format('system(%s)', T)]#> = @record{
      system: System,
      opts: optCollectionT
   }

   function systemT.new(): systemT
      local new_system: systemT = {}

      ## for _, v in ipairs(read_names) do
         new_system.system.read:push(bitset_array.copy(component_masks.#|v|#))
      ## end

      ## for _, v in ipairs(write_names) do
         new_system.system.write:push(bitset_array.copy(component_masks.#|v|#))
      ## end

      new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
      return new_system
   end

   function systemT:verify(): boolean
      local values: boolean[#[ #component_names]#] = {}

      ## for i, v in ipairs(component_names) do
         values[#[i-1]#] = self.opts.#|v|#.filled
      ## end

      local result: boolean = true

      for i = 0, < #[#component_names]# do
         result = result and values[i]
      end

      return result
   end

   function systemT:run()
      for i = 0, < #self.system.system_data.components_indexes do
         local ids = self.system.system_data.components_indexes[i]

         if #ids > 0 then
            ## for i, v in ipairs(component_names) do
               local #|v..'_id'|# = ids[#[i-1]#]
               self.opts.#|v|# = storages.#|v|#:get_entry(#|v..'_id'|#)
            ## end

            if self:verify() then
               ## for _, v in ipairs(component_names) do
                  local #|v|# = self.opts.#|v|#:get()
               ## end

               local runner: #|run_type|# = {}
               ## for _, v in ipairs(component_names) do
                  runner.#|v|# = #|v|#
               ## end

               runner:run()
            else
               self.system.system_data:mark_available(i)
            end
         end
      end
   end

   ## return systemT
## end)

local MakeSystem = #[make_system]#

global CollidersSyncRunner = @record{
   position: Position*,
   velocity: Velocity*,
   collider: Collider*
}

function CollidersSyncRunner:run()
   self.collider:sync_with_position(self.position.position)
end

local CollidersSyncRunnerOptCollection = @record{
   position: optional(Position*),
   velocity: optional(Velocity*),
   collider: optional(Collider*)
}



global CollidersSyncSystem = @MakeSystem(CollidersSyncRunner, 'CollidersSyncRunner', CollidersSyncRunnerOptCollection, 2, 'position', 'velocity', 'Position', 'Velocity', 1, 'collider', 'Collider')

global AnimationRunner = @record{
   animations: Animations*,
   sprite: Sprite*,
}

function AnimationRunner:run()
   if not self.animations.paused then
      self.animations.elapsed_time = self.animations.elapsed_time + Globals.dt
      local current_animation: AnimationData* = self.animations.animations[self.animations.current_animation_index]

      if self.animations.elapsed_time > current_animation.frame_duration then
         self.animations.current_frame_index = (self.animations.current_frame_index + 1) % #current_animation.frame_indexes
         self.animations.elapsed_time = 0
      end

      self.sprite.frame_index = current_animation.frame_indexes[self.animations.current_frame_index]
   end
end

local AnimationRunnerOptCollection = @record{
   animations: optional(Animations*),
   sprite: optional(Sprite*),
}

global AnimationSystem = @MakeSystem(AnimationRunner, 'AnimationRunner', AnimationRunnerOptCollection, 0, 2, 'animations', 'sprite', 'Animations', 'Sprite')

global ShowCollisionsRunner = @record{
   collisions: Collisions*,
}

function ShowCollisionsRunner:run()
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]
      local rect_color: Color = intersection.state == CollisionState.Enter and BLUE or RED
      Raylib.DrawRectangleLinesEx(intersection.rect, 1, rect_color)
   end
end

local ShowCollisionsRunnerOptCollection = @record{
   collisions: optional(Collisions*),
}

global ShowCollisionsSystem = @MakeSystem(ShowCollisionsRunner, 'ShowCollisionsRunner', ShowCollisionsRunnerOptCollection, 1, 'collisions', 'Collisions', 0)

global ShowCollidersRunner = @record{
   collider: Collider*,
}

function ShowCollidersRunner:run()
   Raylib.DrawRectangleLinesEx(self.collider.global_rect, 1, GREEN)
end

local ShowCollidersRunnerOptCollection = @record{
   collider: optional(Collider*),
}

global ShowCollidersSystem = @MakeSystem(ShowCollidersRunner, 'ShowCollidersRunner', ShowCollidersRunnerOptCollection, 1, 'collider', 'Collider', 0)

global ShowPositionsRunner = @record{
   position: Position*,
}

function ShowPositionsRunner:run()
   local H_start: Vector2 = { -5, 0 }
   local H_end  : Vector2 = {  5, 0 }
   local V_start: Vector2 = { 0, -5 }
   local V_end  : Vector2 = { 0,  5 }

   Raylib.DrawLineV(self.position.position + H_start, self.position.position + H_end, RED)
   Raylib.DrawLineV(self.position.position + V_start, self.position.position + V_end, RED)
end

local ShowPositionsRunnerOptCollection = @record{
   position: optional(Position*),
}

global ShowPositionsSystem = @MakeSystem(ShowPositionsRunner, 'ShowPositionsRunner', ShowPositionsRunnerOptCollection, 1, 'position', 'Position', 0)

global CollisionDetectionRunner = @record{
   collider: Collider*,
   collisions: Collisions*,
}

local function is_past_collision(intersections: vector(Intersection)*, collider: Collider*): integer
   for i = 0, < #intersections do
      if intersections[i].collider.entity_id == collider.entity_id then
         return i
      end
   end
   return -1
end

function CollisionDetectionRunner:run()
   for j = 0, < storages.collider.len do
      if storages.collider.generations[j].filled then
         local collider_j = storages.collider.entries[j]

         if self.collider.entity_id ~= collider_j.entity_id then
            local has_collision = Raylib.CheckCollisionRecs(self.collider.global_rect, collider_j.global_rect)
            local possible_past_collision = is_past_collision(self.collisions.intersections, collider_j)

            if has_collision then
               local intersection_rect = Raylib.GetCollisionRec(self.collider.global_rect, collider_j.global_rect)

               if possible_past_collision >= 0 then
                  self.collisions.intersections[possible_past_collision].state = CollisionState.Stay
                  self.collisions.intersections[possible_past_collision].rect = intersection_rect
               else
                  local new_intersection: Intersection = {
                     collider = collider_j,
                     rect = intersection_rect,
                     state = CollisionState.Enter
                  }
                  self.collisions.intersections:push(new_intersection)
               end
            elseif possible_past_collision >= 0 then
               self.collisions.intersections:remove(possible_past_collision)
            end
         end
      end
   end
end

local CollisionDetectionRunnerOptCollection = @record{
   collider: optional(Collider*),
   collisions: optional(Collisions*),
}

global CollisionDetectionSystem = @MakeSystem(CollisionDetectionRunner, 'CollisionDetectionRunner', CollisionDetectionRunnerOptCollection, 1, 'collider', 'Collider', 1, 'collisions', 'Collisions')

global PlayerControllerRunner = @record{
   player: Player*,
   velocity: Velocity*,
   animations: Animations*,
}

function PlayerControllerRunner:run()
   self.velocity.direction = Globals.player_input.direction

   if #Globals.player_input.direction < 0.1 then
      self.animations:change_animation(0)
   elseif math.abs(Globals.player_input.direction.x) > math.abs(Globals.player_input.direction.y) then -- horizontal movement
      if Globals.player_input.action then -- L/R push
         self.animations:change_animation(Globals.player_input.direction.x < 0 and 8 or 7)
      else -- L/R walk
         self.animations:change_animation(Globals.player_input.direction.x < 0 and 4 or 3)
      end
   else -- vertical movement
      if Globals.player_input.action then -- U/D push
         self.animations:change_animation(Globals.player_input.direction.y < 0 and 6 or 5)
      else -- U/D walk
         self.animations:change_animation(Globals.player_input.direction.y < 0 and 2 or 1)
      end
   end
end

local PlayerControllerRunnerOptCollection = @record{
   player: optional(Player*),
   velocity: optional(Velocity*),
   animations: optional(Animations*),
}

global PlayerControllerSystem = @MakeSystem(PlayerControllerRunner, 'PlayerControllerRunner', PlayerControllerRunnerOptCollection, 1, 'player', 'Player', 2, 'velocity', 'animations', 'Velocity', 'Animations')

global BoxControllerRunner = @record{
   box: Box*,
   position: Position*,
   collisions: Collisions*,
   velocity: Velocity*,
}

function BoxControllerRunner:run()
   if Raylib.IsKeyDown(KeyboardKey.KEY_R) then
      self.position.position = self.box.start_position
      self.velocity.direction = { 0, 0 }
   end

   if Globals.player_input.action and #self.collisions.intersections > 0 then
      for j = 0, < #self.collisions.intersections do
         local intersection: Intersection* = self.collisions.intersections[j]
         if intersection:contains_tag(EntityTag.Player) then
            self.velocity.direction = Globals.player_input.direction
            break
         else
            self.velocity.direction = { 0, 0 }
         end
      end
   else
      self.velocity.direction = { 0, 0 }
   end
end

local BoxControllerRunnerOptCollection = @record{
   box: optional(Box*),
   position: optional(Position*),
   collisions: optional(Collisions*),
   velocity: optional(Velocity*),
}

global BoxControllerSystem = @MakeSystem(BoxControllerRunner, 'BoxControllerRunner', BoxControllerRunnerOptCollection, 3, 'box', 'position', 'collisions', 'Box', 'Position', 'Collisions', 1, 'velocity', 'Velocity')

global ObstaclesRunner = @record{
   obstacles: Obstacles*,
   collisions: Collisions*,
   velocity: Velocity*,
}

function ObstaclesRunner:run()
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]

      -- if intersected with a obstacle entity
      if intersection:contains_tag(self.obstacles.mask) then
         local dir: Vector2 = intersection:get_direction(intersection:get_center(), 2)
         local dir_x_inputdir = dir * self.velocity.direction

         if dir_x_inputdir.x < 0 and intersection.rect.width / intersection.rect.height < 1 then
            self.velocity.direction.x = 0
         end
         if dir_x_inputdir.y < 0 and intersection.rect.height / intersection.rect.width < 1 then
            self.velocity.direction.y = 0
         end
      end
   end
end

local ObstaclesRunnerOptCollection = @record{
   obstacles: optional(Obstacles*),
   collisions: optional(Collisions*),
   velocity: optional(Velocity*),
}

global ObstaclesSystem = @MakeSystem(ObstaclesRunner, 'ObstaclesRunner', ObstaclesRunnerOptCollection, 2, 'obstacles', 'collisions', 'Obstacles', 'Collisions', 1, 'velocity', 'Velocity')

global VelocityRunner = @record{
   velocity: Velocity*,
   position: Position*,
}

function VelocityRunner:run()
   self.position.position.x = self.position.position.x + self.velocity.direction.x * self.velocity.speed
   self.position.position.y = self.position.position.y + self.velocity.direction.y * self.velocity.speed
end

local VelocityRunnerOptCollection = @record{
   velocity: optional(Velocity*),
   position: optional(Position*),
}

global VelocitySystem = @MakeSystem(VelocityRunner, 'VelocityRunner', VelocityRunnerOptCollection, 1, 'velocity',  'Velocity', 1, 'position', 'Position')

global GearControllerRunner = @record{
   gear: Gear*,
   collisions: Collisions*,
   velocity: Velocity*,
   position: Position*,
   animations: Animations*,
}

function GearControllerRunner:run()
   if Raylib.IsKeyDown(KeyboardKey.KEY_R) and not self.gear.engaged then
      self.position.position = self.gear.start_position
      self.velocity.direction = { 0, 0 }
   end

   if not self.gear.engaged then
      for j = 0, < #self.collisions.intersections do
         local intersection: Intersection* = self.collisions.intersections[j]

         if intersection:contains_tag(EntityTag.Player) and Globals.player_input.action and #Globals.player_input.direction > 0.01 then
            local dir = Globals.player_input.direction

            local is_horizontal = intersection.rect.width / intersection.rect.height < 1
            local is_vertical = intersection.rect.height / intersection.rect.width < 1

            if is_horizontal then
               dir.x = dir.x > 0 and 1 or -1
               dir.y = 0
            elseif is_vertical then
               dir.x = 0
               dir.y = dir.y > 0 and 1 or -1
            end

            self.velocity.direction = dir
         elseif intersection:contains_tag(EntityTag.GearSlot) then
            self.gear.engaged = true
            break
         end
      end
   else
      for j = 0, < #self.collisions.intersections do
         local intersection: Intersection* = self.collisions.intersections[j]

         if intersection:contains_tag(EntityTag.GearSlot) then
            self.position.position.x = intersection.collider.global_rect.x
            self.position.position.y = intersection.collider.global_rect.y+33
            break
         end
      end
   end

   if not self.gear.engaged then
      local in_movement = #self.velocity.direction > 0.15
      self.animations.paused = not in_movement

      if in_movement then
         local new_anim_idx = math.abs(self.velocity.direction.x) > math.abs(self.velocity.direction.y) and 0 or 1
         self.animations:change_animation(new_anim_idx)
      end
   else
      self.animations:change_animation(2)
   end
end

local GearControllerRunnerOptCollection = @record{
   gear: optional(Gear*),
   collisions: optional(Collisions*),
   velocity: optional(Velocity*),
   position: optional(Position*),
   animations: optional(Animations*),
}

global GearControllerSystem = @MakeSystem(GearControllerRunner, 'GearControllerRunner', GearControllerRunnerOptCollection, 2, 'gear', 'collisions', 'Gear', 'Collisions', 3, 'velocity', 'position', 'animations', 'Velocity', 'Position', 'Animations')

global EngageRunner = @record{
   collisions: Collisions*,
   gear_slot: GearSlot*,
}

function EngageRunner:run()
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]

      if intersection:contains_tag(EntityTag.Gear) then
         Globals.engaged_slots[self.gear_slot.slot_idx] = true
         break
      end
   end
end

local EngageRunnerOptCollection = @record{
   collisions: optional(Collisions*),
   gear_slot: optional(GearSlot*),
}

global EngageSystem = @MakeSystem(EngageRunner, 'EngageRunner', EngageRunnerOptCollection, 1, 'collisions', 'Collisions', 1, 'gear_slot', 'GearSlot')

global BridgeRunner = @record{
   bridge: Bridge*,
   collider: Collider*,
   sprite: Sprite*,
}

function BridgeRunner:run()
   if Globals.engaged_slots[self.bridge.slot_idx] then
      self.collider.entity_tag = EntityTag.OpenBridge
      self.sprite.visible = true
   end
end

local BridgeRunnerOptCollection = @record{
   bridge: optional(Bridge*),
   collider: optional(Collider*),
   sprite: optional(Sprite*),
}

global BridgeSystem = @MakeSystem(BridgeRunner, 'BridgeRunner', BridgeRunnerOptCollection, 1, 'bridge', 'Bridge', 2, 'collider', 'sprite', 'Collider', 'Sprite')

-- ] systems ]
