require 'math'
require 'vector'
require 'raylib'
require 'rotor'
require 'game.components'

global System = @record{
   read: vector(BitsetArray),
   write: vector(BitsetArray),
   system_data: SystemData
}

-- [ systems [
global CollidersSync = @record{
   system: System
}

function CollidersSync.new(): CollidersSync
   local new_system: CollidersSync = {
      system = {
         read = {
            bitset_array.copy(component_masks.position),
            bitset_array.copy(component_masks.velocity)
         },
         write = {
            bitset_array.copy(component_masks.collider),
         },
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function CollidersSync:run(position_storage: Storage(Position)*, velocity_storage: Storage(Velocity)*, collider_storage: Storage(Collider)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local position_id = ids[0]
         local velocity_id = ids[1]
         local collider_id = ids[2]

         local opt_position = position_storage:get_entry(position_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)
         local opt_collider = collider_storage:get_entry(collider_id)

         if opt_position.filled and opt_velocity.filled and opt_collider.filled then
            local position = opt_position:get()
            local velocity = opt_velocity:get()
            local collider = opt_collider:get()

            collider:sync_with_position(position.position)
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global SpritePainter = @record{
   system: System
}

function SpritePainter.new(): SpritePainter
   local new_system: SpritePainter = {
      system = {
         read = {bitset_array.copy(component_masks.sprite), bitset_array.copy(component_masks.position)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function SpritePainter:run(sprite_storage: Storage(Sprite)*, position_storage: Storage(Position)*)
   local sys_len = #self.system.system_data.components_indexes

   local draw_order: vector(uinteger) = {}
   draw_order:reserve(sys_len)

   local y_vec: vector(float32) = {}
   y_vec:reserve(sys_len)

   for i = 0, < sys_len do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = sprite_storage:get_entry(sprite_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local position = opt_position:get()

            if  #draw_order == 0 then
               y_vec:push(position.position.y)
               draw_order:push(i)
            else
               local inserted = false
               for j = 0, < #draw_order do
                  if position.position.y < y_vec[j] then
                     y_vec:insert(j, position.position.y)
                     draw_order:insert(j, i)
                     inserted = true
                     break
                  end
               end
               if not inserted then
                  y_vec:push(position.position.y)
                  draw_order:push(i)
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end

   for i = 0, < sys_len do
      local ids = self.system.system_data.components_indexes[ draw_order[i] ]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = sprite_storage:get_entry(sprite_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local sprite = opt_sprite:get()
            if sprite.visible then
               local position = opt_position:get()

               local img_unit_w: integer = sprite.sprite_sheet.width // sprite.frame_rect.width
               local img_unit_h: integer = sprite.sprite_sheet.height // sprite.frame_rect.height

               sprite.frame_rect.x = (sprite.frame_index % img_unit_w) * sprite.frame_rect.width
               sprite.frame_rect.y = (sprite.frame_index // img_unit_w) * sprite.frame_rect.height

               Raylib.DrawTextureRec(sprite.sprite_sheet, sprite.frame_rect, position.position + sprite.offset, WHITE)
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global Animation = @record{
   system: System
}

function Animation.new(): Animation
   local new_system: Animation = {
      system = {
         read = {},
         write = {bitset_array.copy(component_masks.animations), bitset_array.copy(component_masks.sprite)}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function Animation:run(animations_storage: Storage(Animations)*, sprite_storage: Storage(Sprite)*, dt: number)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local animations_id = ids[0]
         local sprite_id = ids[1]

         local opt_animations = animations_storage:get_entry(animations_id)
         local opt_sprite = sprite_storage:get_entry(sprite_id)

         if opt_animations.filled and opt_sprite.filled then
            local animations = opt_animations:get()
            local sprite = opt_sprite:get()

            if not animations.paused then
               animations.elapsed_time = animations.elapsed_time + dt
               local current_animation: AnimationData* = animations.animations[animations.current_animation_index]

               if animations.elapsed_time > current_animation.frame_duration then
                  animations.current_frame_index = (animations.current_frame_index + 1) % #current_animation.frame_indexes
                  animations.elapsed_time = 0
               end

               sprite.frame_index = current_animation.frame_indexes[animations.current_frame_index]
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global ShowCollisions = @record{
   system: System
}

function ShowCollisions.new(): ShowCollisions
   local new_system: ShowCollisions = {
      system = {
         read = {bitset_array.copy(component_masks.collisions)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function ShowCollisions:run(collisions_storage: Storage(Collisions)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local collisions_id = ids[0]
         local opt_collisions = collisions_storage:get_entry(collisions_id)

         if opt_collisions.filled then
            local collisions = opt_collisions:get()

            for j = 0, < #collisions.intersections do
               local intersection: Intersection* = collisions.intersections[j]
               local rect_color: Color = intersection.state == CollisionState.Enter and BLUE or RED
               Raylib.DrawRectangleLinesEx(intersection.rect, 1, rect_color)
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global ShowColliders = @record{
   system: System
}

function ShowColliders.new(): ShowColliders
   local new_system: ShowColliders = {
      system = {
         read = {bitset_array.copy(component_masks.collider)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function ShowColliders:run(collider_storage: Storage(Collider)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local collider_id = ids[0]
         local opt_collider = collider_storage:get_entry(collider_id)

         if opt_collider.filled then
            local collider = opt_collider:get()
            Raylib.DrawRectangleLinesEx(collider.global_rect, 1, GREEN)
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global ShowPositions = @record{
   system: System
}

function ShowPositions.new(): ShowPositions
   local new_system: ShowPositions = {
      system = {
         read = {bitset_array.copy(component_masks.position)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function ShowPositions:run(position_storage: Storage(Position)*)
   local H_start: Vector2 = { -5, 0 }
   local H_end  : Vector2 = {  5, 0 }
   local V_start: Vector2 = { 0, -5 }
   local V_end  : Vector2 = { 0,  5 }

   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local position_id = ids[0]
         local opt_position = position_storage:get_entry(position_id)

         if opt_position.filled then
            local position = opt_position:get()
            Raylib.DrawLineV(position.position + H_start, position.position + H_end, RED)
            Raylib.DrawLineV(position.position + V_start, position.position + V_end, RED)
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global CollisionDetection = @record{
   system: System
}

local function is_past_collision(intersections: vector(Intersection)*, collider: Collider*): integer
   for i = 0, < #intersections do
      if intersections[i].collider.entity_id == collider.entity_id then
         return i
      end
   end
   return -1
end

function CollisionDetection.new(): CollisionDetection
   local new_system: CollisionDetection = {
      system = {
         read = {bitset_array.copy(component_masks.collider)},
         write = {bitset_array.copy(component_masks.collisions)},
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function CollisionDetection:run(collider_storage: Storage(Collider)*, collisions_storage: Storage(Collisions)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local collider_id = ids[0]
         local collisions_id = ids[1]

         local opt_collider = collider_storage:get_entry(collider_id)
         local opt_collisions = collisions_storage:get_entry(collisions_id)

         if opt_collider.filled  and opt_collisions.filled then
            local collider = opt_collider:get()
            local collisions = opt_collisions:get()

            for j = 0, < collider_storage.len do
               if collider_storage.generations[j].filled then
                  local collider_j = collider_storage.entries[j]

                  if collider.entity_id ~= collider_j.entity_id then
                     local has_collision = Raylib.CheckCollisionRecs(collider.global_rect, collider_j.global_rect)
                     local possible_past_collision = is_past_collision(collisions.intersections, collider_j)

                     if has_collision then
                        local intersection_rect = Raylib.GetCollisionRec(collider.global_rect, collider_j.global_rect)

                        if possible_past_collision >= 0 then
                           collisions.intersections[possible_past_collision].state = CollisionState.Stay
                           collisions.intersections[possible_past_collision].rect = intersection_rect
                        else
                           local new_intersection: Intersection = {
                              collider = collider_j,
                              rect = intersection_rect,
                              state = CollisionState.Enter
                           }
                           collisions.intersections:push(new_intersection)
                        end
                     elseif possible_past_collision >= 0 then
                        collisions.intersections:remove(possible_past_collision)
                     end
                  end
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global PlayerController = @record{
   system: System
}

function PlayerController.new(): PlayerController
   local new_system: PlayerController = {
      system = {
         read = { bitset_array.copy(component_masks.player) },
         write = { bitset_array.copy(component_masks.velocity) }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function PlayerController:run(
   player_storage: Storage(Player)*,
   velocity_storage: Storage(Velocity)*,
   player_input: PlayerInput
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local player_id = ids[0]
         local velocity_id = ids[1]

         local opt_player = player_storage:get_entry(player_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)

         if opt_player.filled and opt_velocity.filled then
            local player = opt_player:get()
            local velocity = opt_velocity:get()

            velocity.direction = player_input.direction
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global BoxController = @record{
   system: System
}

function BoxController.new(): BoxController
   local new_system: BoxController = {
      system = {
         read = {
            bitset_array.copy(component_masks.box),
            bitset_array.copy(component_masks.position),
            bitset_array.copy(component_masks.collisions)
         },
         write = { bitset_array.copy(component_masks.velocity) }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function BoxController:run(
   box_storage: Storage(Box)*,
   position_storage: Storage(Position)*,
   collisions_storage: Storage(Collisions)*,
   velocity_storage: Storage(Velocity),
   player_input: PlayerInput,
   player_position: Vector2
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local box_id = ids[0]
         local position_id = ids[1]
         local collisions_id = ids[2]
         local velocity_id = ids[3]

         local opt_box = box_storage:get_entry(box_id)
         local opt_position = position_storage:get_entry(position_id)
         local opt_collisions = collisions_storage:get_entry(collisions_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)

         if opt_box.filled and opt_position.filled and opt_collisions.filled and opt_velocity.filled then
            local box = opt_box:get()
            local position = opt_position:get()
            local collisions = opt_collisions:get()
            local velocity = opt_velocity:get()

            if player_input.action and #collisions.intersections > 0 then
               for j = 0, < #collisions.intersections do
                  local intersection: Intersection* = collisions.intersections[j]
                  if intersection:contains_tag(EntityTag.Player) then
                     velocity.direction = player_input.direction
                     break
                  else
                     velocity.direction = { 0, 0 }
                  end
               end
            else
               velocity.direction = { 0, 0 }
            end
         end
      end
   end
end

global ObstaclesSystem = @record{
   system: System
}

function ObstaclesSystem.new(): ObstaclesSystem
   local new_system: ObstaclesSystem = {
      system = {
         read = { bitset_array.copy(component_masks.obstacles), bitset_array.copy(component_masks.collisions) },
         write = { bitset_array.copy(component_masks.velocity) }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function ObstaclesSystem:run(
   obstacles_storage: Storage(Obstacles)*,
   collisions_storage: Storage(Collisions)*,
   velocity_storage: Storage(Velocity)*
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local obstacles_id = ids[0]
         local collisions_id = ids[1]
         local velocity_id = ids[2]

         local opt_obstacles = obstacles_storage:get_entry(obstacles_id)
         local opt_collisions = collisions_storage:get_entry(collisions_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)

         if opt_obstacles.filled and opt_collisions.filled and opt_velocity.filled then
            local obstacles = opt_obstacles:get()
            local collisions = opt_collisions:get()
            local velocity = opt_velocity:get()

            for j = 0, < #collisions.intersections do
               local intersection: Intersection* = collisions.intersections[j]

               -- if intersected with a obstacle entity
               if intersection:contains_tag(obstacles.mask) then
                  local dir: Vector2 = intersection:get_direction(intersection:get_center(), 2)
                  local dir_x_inputdir = dir * velocity.direction


                  if dir_x_inputdir.x < 0 and intersection.rect.width / intersection.rect.height < 1 then
                     velocity.direction.x = 0
                  end
                  if dir_x_inputdir.y < 0 and intersection.rect.height / intersection.rect.width < 1 then
                     velocity.direction.y = 0
                  end
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global VelocitySystem = @record{
   system: System
}

function VelocitySystem.new(): VelocitySystem
   local new_system: VelocitySystem = {
      system = {
         read = { bitset_array.copy(component_masks.velocity) },
         write = { bitset_array.copy(component_masks.position) }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function VelocitySystem:run(velocity_storage: Storage(Velocity)*, position_storage: Storage(Position)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local velocity_id = ids[0]
         local position_id = ids[1]

         local opt_velocity = velocity_storage:get_entry(velocity_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_velocity.filled and opt_position.filled then
            local velocity = opt_velocity:get()
            local position = opt_position:get()

            position.position.x = position.position.x + velocity.direction.x * velocity.speed
            position.position.y = position.position.y + velocity.direction.y * velocity.speed
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global GearController = @record{
   system: System
}

function GearController.new(): GearController
   local new_system: GearController = {
      system = {
         read = {
            bitset_array.copy(component_masks.gear),
            bitset_array.copy(component_masks.collisions)
         },
         write = {
            bitset_array.copy(component_masks.velocity),
            bitset_array.copy(component_masks.position),
            bitset_array.copy(component_masks.animations)
         }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function GearController:run(
   gear_storage: Storage(Gear)*,
   collisions_storage: Storage(Collisions)*,
   velocity_storage: Storage(Velocity)*,
   position_storage: Storage(Position)*,
   animations_storage: Storage(Animations)*,
   player_input: PlayerInput,
   engaged_slots: vector(boolean)*
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local gear_id = ids[0]
         local collisions_id = ids[1]
         local velocity_id = ids[2]
         local position_id = ids[3]
         local animations_id = ids[4]

         local opt_gear = gear_storage:get_entry(gear_id)
         local opt_collisions = collisions_storage:get_entry(collisions_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)
         local opt_position = position_storage:get_entry(position_id)
         local opt_animations = animations_storage:get_entry(animations_id)

         if opt_gear.filled and
            opt_collisions.filled and
            opt_velocity.filled and
            opt_position.filled and
            opt_animations.filled
         then
            local gear = opt_gear:get()
            local collisions = opt_collisions:get()
            local velocity = opt_velocity:get()
            local position = opt_position:get()
            local animations = opt_animations:get()

            if not gear.engaged then
               for j = 0, < #collisions.intersections do
                  local intersection: Intersection* = collisions.intersections[j]

                  if intersection:contains_tag(EntityTag.Player) and player_input.action then
                     local dir = intersection:get_direction(intersection:get_center(), 2)
                     if math.abs(dir.x) > math.abs(dir.y) then
                        dir.y = 0
                     else
                        dir.x = 0
                     end
                     velocity.direction = dir
                  elseif intersection:contains_tag(EntityTag.GearSlot) then
                     gear.engaged = true
                     break
                  end
               end
            else
               for j = 0, < #collisions.intersections do
                  local intersection: Intersection* = collisions.intersections[j]

                  if intersection:contains_tag(EntityTag.GearSlot) then
                     position.position.x = intersection.collider.global_rect.x
                     position.position.y = intersection.collider.global_rect.y+33
                     break
                  end
               end
            end


            local in_movement = #velocity.direction > 0.15
            animations.paused = not in_movement

            if in_movement then
               animations.current_animation_index = math.abs(velocity.direction.x) > math.abs(velocity.direction.y) and 0 or 1
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global EngageSystem = @record{
   system: System
}

function EngageSystem.new(): EngageSystem
   local new_system: EngageSystem = {
      system = {
         read = { bitset_array.copy(component_masks.collisions) },
         write = { bitset_array.copy(component_masks.gear_slot) }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function EngageSystem:run(
   collisions_storage: Storage(Collisions)*,
   gear_slot_storage: Storage(GearSlot)*,
   engaged_slots: vector(boolean)*
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local collisions_id = ids[0]
         local gear_slot_id = ids[1]

         local opt_collisions = collisions_storage:get_entry(collisions_id)
         local opt_gear_slot = gear_slot_storage:get_entry(gear_slot_id)

         if opt_collisions.filled and opt_gear_slot.filled then
            local collisions = opt_collisions:get()
            local gear_slot = opt_gear_slot:get()

            for j = 0, < #collisions.intersections do
               local intersection: Intersection* = collisions.intersections[j]

               if intersection:contains_tag(EntityTag.Gear) then
                  engaged_slots[gear_slot.slot_idx] = true
                  break
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global BridgeSystem = @record{
   system: System
}

function BridgeSystem.new(): BridgeSystem
   local new_system: BridgeSystem = {
      system = {
         read = { bitset_array.copy(component_masks.bridge) },
         write = { bitset_array.copy(component_masks.collider), bitset_array.copy(component_masks.sprite) }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function BridgeSystem:run(
   bridge_storage: Storage(Bridge)*,
   collider_storage: Storage(Collider)*,
   sprite_storage: Storage(Sprite)*,
   engaged_slots: vector(boolean)*
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local bridge_id = ids[0]
         local collider_id = ids[1]
         local sprite_id = ids[2]

         local opt_bridge = bridge_storage:get_entry(bridge_id)
         local opt_collider = collider_storage:get_entry(collider_id)
         local opt_sprite = sprite_storage:get_entry(sprite_id)

         if opt_bridge.filled and opt_collider.filled and opt_sprite.filled then
            local bridge = opt_bridge:get()
            local collider = opt_collider:get()
            local sprite = opt_sprite:get()

            if engaged_slots[bridge.slot_idx] then
               collider.entity_tag = EntityTag.OpenBridge
               sprite.visible = true
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end
-- ] systems ]
