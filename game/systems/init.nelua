require 'math'
require 'vector'
require 'raylib'
require 'rotor'
require 'game.components'

global System = @record{
   read: vector(BitsetArray),
   write: vector(BitsetArray),
   system_data: SystemData,
}

## local make_system = generalize(function(T, use_before, use_run, use_after, read_count, ...)
   ##[[
      staticassert(traits.is_type(T), "invalid type %s", T)
      local metalib = require 'metalib'

      local read_names, read_types = metalib.collect_doubles(1, read_count*2, ...)
      local write_names, write_types = metalib.collect_doubles(read_count*2+1, -1, ...)
      local component_names = metalib.tableunion(read_names, write_names)
      local component_types = metalib.tableunion(read_types, write_types)
   ]]

   local T = @#[T]#

   local optCollectionT = @record{}

   ## for i, name in ipairs(component_names) do
      local opt_T: type = @optional(#[ component_types[i] ]#*)
      ## optCollectionT.value:add_field(name, opt_T.value)
   ## end

   local systemT <nickname #[string.format('system(%s)', T)]#> = @record{
      system: System,
      opts: optCollectionT
   }

   ## systemT.value.subtype = T

   function systemT.new(): systemT
      local new_system: systemT = {}

      new_system.system.read:reserve(#[#read_names]#)
      new_system.system.write:reserve(#[#read_names]#)

      ## for _, name in ipairs(read_names) do
         new_system.system.read:push(bitset_array.copy(component_masks.#|name|#))
      ## end

      ## for _, name in ipairs(write_names) do
         new_system.system.write:push(bitset_array.copy(component_masks.#|name|#))
      ## end

      new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
      return new_system
   end

   function systemT:verify(): boolean
      local values: array(boolean, #[ #component_names]#) = {}
      local result: boolean = true

      ## for i, name in ipairs(component_names) do
         values[#[i-1]#] = self.opts.#|name|#.filled
      ## end

      for i = 0, < #[#component_names]# do
         result = result and values[i]
      end

      return result
   end

   function systemT:run()
      local runner: #|T.nickname|# = {}

      ## if use_before then
         runner:before_all(self.system.system_data)
      ## end

      ## if use_run then
         for i = 0, < #self.system.system_data.components_indexes do
            local ids = self.system.system_data.components_indexes[i]

            if #ids > 0 then
               ## for i, name in ipairs(component_names) do
                  ## local name_id = name..'_id'
                  local #|name_id|# = ids[#[i-1]#]
                  self.opts.#|name|# = storages.#|name|#:get_entry(#|name_id|#)
               ## end

               if self:verify() then
                  ## for _, name in ipairs(component_names) do
                     runner.#|name|# = self.opts.#|name|#:get()
                  ## end

                  runner:run(self.system.system_data)
               else
                  self.system.system_data:mark_available(i)
               end
            end
         end
      ## end

      ## if use_before then
      runner:after_all(self.system.system_data)
      ## end
   end

   ## return systemT
## end)

local MakeSystem = #[make_system]#

-- [ systems [
global SpritePainterRunner = @record{
   sprite: Sprite*,
   position: Position*,
   draw_order: vector(uinteger),
   sorted: boolean,
}
function SpritePainterRunner:before_all(system_data: SystemData*)
   local sys_len = #system_data.components_indexes

   self.draw_order:clear()

   local y_vec: vector(float32) = {}
   y_vec:reserve(sys_len)

   for i = 0, < sys_len do
      local ids = system_data.components_indexes[i]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = storages.sprite:get_entry(sprite_id)
         local opt_position = storages.position:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local position = opt_position:get()

            if  #self.draw_order == 0 then
               y_vec:push(position.position.y)
               self.draw_order:push(i)
            else
               local inserted = false
               for j = 0, < #self.draw_order do
                  if position.position.y < y_vec[j] then
                     y_vec:insert(j, position.position.y)
                     self.draw_order:insert(j, i)
                     inserted = true
                     break
                  end
               end
               if not inserted then
                  y_vec:push(position.position.y)
                  self.draw_order:push(i)
               end
            end
         else
            system_data:mark_available(i)
         end
      end
   end
end

function SpritePainterRunner:after_all(system_data: SystemData*)
   for i = 0, < #system_data.components_indexes do
      local ids = system_data.components_indexes[ self.draw_order[i] ]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = storages.sprite:get_entry(sprite_id)
         local opt_position = storages.position:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local sprite = opt_sprite:get()
            if sprite.visible then
               local position = opt_position:get()

               local img_unit_w: integer = sprite.sprite_sheet.width // sprite.frame_rect.width
               local img_unit_h: integer = sprite.sprite_sheet.height // sprite.frame_rect.height

               sprite.frame_rect.x = (sprite.frame_index % img_unit_w) * sprite.frame_rect.width
               sprite.frame_rect.y = (sprite.frame_index // img_unit_w) * sprite.frame_rect.height

               Raylib.DrawTextureRec(sprite.sprite_sheet, sprite.frame_rect, position.position + sprite.offset, WHITE)
            end
         else
            system_data:mark_available(i)
         end
      end
   end
end

global SpritePainterSystem = @MakeSystem(
   SpritePainterRunner,
   true, false, true, 2,
   'sprite', Sprite,
   'position', Position
)

global CollidersSyncRunner = @record{
   position: Position*,
   velocity: Velocity*,
   collider: Collider*
}

function CollidersSyncRunner:run(system_data: SystemData*)
   self.collider:sync_with_position(self.position.position)
end

global CollidersSyncSystem = @MakeSystem(
   CollidersSyncRunner,
   false, true, false, 2,
   'position', Position,
   'velocity', Velocity,

   'collider', Collider
)

global AnimationRunner = @record{
   animations: Animations*,
   sprite: Sprite*,
}

function AnimationRunner:run(system_data: SystemData*)
   if not self.animations.paused then
      self.animations.elapsed_time = self.animations.elapsed_time + Globals.dt
      local current_animation: AnimationData* = self.animations.animations[self.animations.current_animation_index]

      if self.animations.elapsed_time > current_animation.frame_duration then
         self.animations.current_frame_index = (self.animations.current_frame_index + 1) % #current_animation.frame_indexes
         self.animations.elapsed_time = 0
      end

      self.sprite.frame_index = current_animation.frame_indexes[self.animations.current_frame_index]
   end
end

global AnimationSystem = @MakeSystem(
   AnimationRunner,
   false, true, false, 0,
   'animations', Animations,
   'sprite', Sprite
)

global ShowCollisionsRunner = @record{
   position: Position*,
   collisions: Collisions*,
}

function ShowCollisionsRunner:run(system_data: SystemData*)
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]
      local rect_color: Color = intersection.state == CollisionState.Enter and BLUE or RED
      Raylib.DrawLineV(self.position.position, (@Vector2){ intersection.rect.x, intersection.rect.y}, rect_color)
      Raylib.DrawRectangleLinesEx(intersection.rect, 1, rect_color)
   end
end

global ShowCollisionsSystem = @MakeSystem(
   ShowCollisionsRunner,
   false, true, false, 2,
   'position', Position,
   'collisions', Collisions
)

global ShowCollidersRunner = @record{
   collider: Collider*,
}

function ShowCollidersRunner:run(system_data: SystemData*)
   Raylib.DrawRectangleLinesEx(self.collider.global_rect, 1, GREEN)
end

global ShowCollidersSystem = @MakeSystem(
   ShowCollidersRunner,
   false, true, false, 1,
   'collider', Collider
)

global ShowPositionsRunner = @record{
   position: Position*,
}

function ShowPositionsRunner:run(system_data: SystemData*)
   local H_start: Vector2 = { -5, 0 }
   local H_end  : Vector2 = {  5, 0 }
   local V_start: Vector2 = { 0, -5 }
   local V_end  : Vector2 = { 0,  5 }

   Raylib.DrawLineV(self.position.position + H_start, self.position.position + H_end, RED)
   Raylib.DrawLineV(self.position.position + V_start, self.position.position + V_end, RED)
end

global ShowPositionsSystem = @MakeSystem(
   ShowPositionsRunner,
   false, true, false, 1,
   'position', Position
)

global ShowObstaclesRunner = @record{
   position: Position*,
   obstacles: Obstacles*,
   collisions: Collisions*,
}

function ShowObstaclesRunner:run(system_data: SystemData*)
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]

       --if intersected with a obstacle entity
      if intersection:contains_tag(self.obstacles.mask) then
         local intersection_center = intersection:get_center()
         Raylib.DrawLineV(self.position.position, intersection_center, GOLD)
         Raylib.DrawCircleLines(intersection_center.x // 1, intersection_center.y // 1, 5, GOLD)
      end
   end
end

global ShowObstaclesSystem = @MakeSystem(
   ShowObstaclesRunner,
   false, true, false, 3,
   'position', Position,
   'obstacles', Obstacles,
   'collisions', Collisions
)

global CollisionDetectionRunner = @record{
   collider: Collider*,
   collisions: Collisions*,
}

local function is_past_collision(intersections: vector(Intersection)*, collider: Collider*): integer
   for i = 0, < #intersections do
      if intersections[i].collider.entity_id == collider.entity_id then
         return i
      end
   end
   return -1
end

function CollisionDetectionRunner:run(system_data: SystemData*)
   for j = 0, < storages.collider.len do
      if storages.collider.generations[j].filled then
         local collider_j = storages.collider.entries[j]

         if self.collider.entity_id ~= collider_j.entity_id then
            local has_collision = Raylib.CheckCollisionRecs(self.collider.global_rect, collider_j.global_rect)
            local possible_past_collision = is_past_collision(self.collisions.intersections, collider_j)

            if has_collision then
               local intersection_rect = Raylib.GetCollisionRec(self.collider.global_rect, collider_j.global_rect)

               if possible_past_collision >= 0 then
                  self.collisions.intersections[possible_past_collision].state = CollisionState.Stay
                  self.collisions.intersections[possible_past_collision].rect = intersection_rect
               else
                  local new_intersection: Intersection = {
                     collider = collider_j,
                     rect = intersection_rect,
                     state = CollisionState.Enter
                  }
                  self.collisions.intersections:push(new_intersection)
               end
            elseif possible_past_collision >= 0 then
               self.collisions.intersections:remove(possible_past_collision)
            end
         end
      end
   end
end

global CollisionDetectionSystem = @MakeSystem(
   CollisionDetectionRunner,
   false, true, false, 1,
   'collider', Collider,

   'collisions', Collisions
)

global PlayerControllerRunner = @record{
   player: Player*,
   velocity: Velocity*,
   animations: Animations*,
}

function PlayerControllerRunner:run(system_data: SystemData*)
   self.velocity.direction = Globals.player_input.direction

   if #Globals.player_input.direction < 0.1 then
      self.animations:change_animation(0)
   elseif math.abs(Globals.player_input.direction.x) > math.abs(Globals.player_input.direction.y) then -- horizontal movement
      if Globals.player_input.action then -- L/R push
         self.animations:change_animation(Globals.player_input.direction.x < 0 and 8 or 7)
      else -- L/R walk
         self.animations:change_animation(Globals.player_input.direction.x < 0 and 4 or 3)
      end
   else -- vertical movement
      if Globals.player_input.action then -- U/D push
         self.animations:change_animation(Globals.player_input.direction.y < 0 and 6 or 5)
      else -- U/D walk
         self.animations:change_animation(Globals.player_input.direction.y < 0 and 2 or 1)
      end
   end
end

global PlayerControllerSystem = @MakeSystem(
   PlayerControllerRunner,
   false, true, false, 1,
   'player', Player,

   'velocity', Velocity,
   'animations', Animations
)

global BoxControllerRunner = @record{
   box: Box*,
   position: Position*,
   collisions: Collisions*,
   velocity: Velocity*,
}

function BoxControllerRunner:run(system_data: SystemData*)
   if Raylib.IsKeyDown(KeyboardKey.KEY_R) then
      self.position.position = self.box.start_position
      self.velocity.direction = { 0, 0 }
   end

   if Globals.player_input.action and #self.collisions.intersections > 0 then
      for j = 0, < #self.collisions.intersections do
         local intersection: Intersection* = self.collisions.intersections[j]
         if intersection:contains_tag(EntityTag.Player) then
            self.velocity.direction = Globals.player_input.direction
            break
         else
            self.velocity.direction = { 0, 0 }
         end
      end
   else
      self.velocity.direction = { 0, 0 }
   end
end

global BoxControllerSystem = @MakeSystem(
   BoxControllerRunner,
   false, true, false, 3,
   'box', Box,
   'position', Position,
   'collisions', Collisions,

   'velocity', Velocity
)

global ObstaclesRunner = @record{
   obstacles: Obstacles*,
   collisions: Collisions*,
   velocity: Velocity*,
}

function ObstaclesRunner:run(system_data: SystemData*)
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]

      -- if intersected with a obstacle entity
      if intersection:contains_tag(self.obstacles.mask) then
         local dir: Vector2 = intersection:get_direction(intersection:get_center(), 2)
         local dir_x_inputdir = dir * self.velocity.direction

         if dir_x_inputdir.x < 0 and intersection.rect.width / intersection.rect.height < 1 then
            self.velocity.direction.x = 0
         end
         if dir_x_inputdir.y < 0 and intersection.rect.height / intersection.rect.width < 1 then
            self.velocity.direction.y = 0
         end
      end
   end
end

global ObstaclesSystem = @MakeSystem(
   ObstaclesRunner,
   false, true, false, 2,
   'obstacles', Obstacles,
   'collisions', Collisions,

   'velocity', Velocity
)

global VelocityRunner = @record{
   velocity: Velocity*,
   position: Position*,
}

function VelocityRunner:run(system_data: SystemData*)
   self.position.position.x = self.position.position.x + self.velocity.direction.x * self.velocity.speed
   self.position.position.y = self.position.position.y + self.velocity.direction.y * self.velocity.speed
end

global VelocitySystem = @MakeSystem(
   VelocityRunner,
   false, true, false, 1,
   'velocity',  Velocity,

   'position', Position
)

global GearControllerRunner = @record{
   gear: Gear*,
   collisions: Collisions*,
   velocity: Velocity*,
   position: Position*,
   animations: Animations*,
}

function GearControllerRunner:run(system_data: SystemData*)
   if Raylib.IsKeyDown(KeyboardKey.KEY_R) and not self.gear.engaged then
      self.position.position = self.gear.start_position
      self.velocity.direction = { 0, 0 }
   end

   if not self.gear.engaged then
      for j = 0, < #self.collisions.intersections do
         local intersection: Intersection* = self.collisions.intersections[j]

         if intersection:contains_tag(EntityTag.Player) and Globals.player_input.action and #Globals.player_input.direction > 0.01 then
            local dir = Globals.player_input.direction

            local is_horizontal = intersection.rect.width / intersection.rect.height < 1
            local is_vertical = intersection.rect.height / intersection.rect.width < 1

            if is_horizontal then
               dir.x = dir.x > 0 and 1 or -1
               dir.y = 0
            elseif is_vertical then
               dir.x = 0
               dir.y = dir.y > 0 and 1 or -1
            end

            self.velocity.direction = dir
         elseif intersection:contains_tag(EntityTag.GearSlot) then
            self.gear.engaged = true
            break
         end
      end
   else
      for j = 0, < #self.collisions.intersections do
         local intersection: Intersection* = self.collisions.intersections[j]

         if intersection:contains_tag(EntityTag.GearSlot) then
            self.position.position.x = intersection.collider.global_rect.x
            self.position.position.y = intersection.collider.global_rect.y+33
            break
         end
      end
   end

   if not self.gear.engaged then
      local in_movement = #self.velocity.direction > 0.15
      self.animations.paused = not in_movement

      if in_movement then
         local new_anim_idx = math.abs(self.velocity.direction.x) > math.abs(self.velocity.direction.y) and 0 or 1
         self.animations:change_animation(new_anim_idx)
      end
   else
      self.animations:change_animation(2)
   end
end

global GearControllerSystem = @MakeSystem(
   GearControllerRunner,
   false, true, false, 2,
   'gear', Gear,
   'collisions', Collisions,

   'velocity', Velocity,
   'position', Position,
   'animations', Animations
)

global EngageRunner = @record{
   collisions: Collisions*,
   gear_slot: GearSlot*,
}

function EngageRunner:run(system_data: SystemData*)
   for j = 0, < #self.collisions.intersections do
      local intersection: Intersection* = self.collisions.intersections[j]

      if intersection:contains_tag(EntityTag.Gear) then
         Globals.engaged_slots[self.gear_slot.slot_idx] = true
         break
      end
   end
end

global EngageSystem = @MakeSystem(
   EngageRunner,
   false, true, false, 1,
   'collisions', Collisions,

   'gear_slot', GearSlot
)

global BridgeRunner = @record{
   bridge: Bridge*,
   collider: Collider*,
   sprite: Sprite*,
}

function BridgeRunner:run(system_data: SystemData*)
   if Globals.engaged_slots[self.bridge.slot_idx] then
      self.collider.entity_tag = EntityTag.OpenBridge
      self.sprite.visible = true
   end
end

global BridgeSystem = @MakeSystem(
   BridgeRunner,
   false, true, false, 1,
   'bridge', Bridge,

   'collider', Collider,
   'sprite', Sprite
)

-- ] systems ]
