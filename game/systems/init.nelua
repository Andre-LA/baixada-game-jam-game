require 'raylib'
require 'rotor'

require 'game.components'

require 'vector'

local System = @record{
   read: vector(BitsetArray),
   write: vector(BitsetArray),
   system_data: SystemData
}

-- [ systems [
global CollidersSync = @record{
   system: System
}

function CollidersSync.new(): CollidersSync
   local new_system: CollidersSync = {
      system = {
         read = {
            bitset_array.copy(component_masks.position),
            bitset_array.copy(component_masks.velocity)
         },
         write = {
            bitset_array.copy(component_masks.collider),
         },
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function CollidersSync:run(position_storage: Storage(Position)*, velocity_storage: Storage(Velocity)*, collider_storage: Storage(Collider)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local position_id = ids[0]
         local velocity_id = ids[1]
         local collider_id = ids[2]

         local opt_position = position_storage:get_entry(position_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)
         local opt_collider = collider_storage:get_entry(collider_id)

         if opt_position.filled and opt_velocity.filled and opt_collider.filled then
            local position = opt_position:get()
            local velocity = opt_velocity:get()
            local collider = opt_collider:get()

            collider.global_rect.x = collider.local_rect.x + position.position.x
            collider.global_rect.y = collider.local_rect.y + position.position.y
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global SpritePainter = @record{
   system: System
}

function SpritePainter.new(): SpritePainter
   local new_system: SpritePainter = {
      system = {
         read = {bitset_array.copy(component_masks.sprite), bitset_array.copy(component_masks.position)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function SpritePainter:run(sprite_storage: Storage(Sprite)*, position_storage: Storage(Position)*)
   local sys_len = #self.system.system_data.components_indexes

   local draw_order: vector(uinteger) = {}
   draw_order:reserve(sys_len)

   local y_vec: vector(float32) = {}
   y_vec:reserve(sys_len)

   for i = 0, < sys_len do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = sprite_storage:get_entry(sprite_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local sprite = opt_sprite:get()
            local position = opt_position:get()

            if  #draw_order == 0 then
               y_vec:push(position.position.y)
               draw_order:push(i)
            else
               local inserted = false
               for j = 0, < #draw_order do
                  if position.position.y < y_vec[j] then
                     y_vec:insert(j, position.position.y)
                     draw_order:insert(j, i)
                     inserted = true
                     break
                  end
               end
               if not inserted then
                  y_vec:push(position.position.y)
                  draw_order:push(i)
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end

   for i = 0, < sys_len do
      local ids = self.system.system_data.components_indexes[ draw_order[i] ]

      if #ids > 0 then
         local sprite_id = ids[0]
         local position_id = ids[1]

         local opt_sprite = sprite_storage:get_entry(sprite_id)
         local opt_position = position_storage:get_entry(position_id)

         if opt_sprite.filled and opt_position.filled then
            local sprite = opt_sprite:get()
            local position = opt_position:get()

            local img_unit_w: integer = sprite.sprite_sheet.width // sprite.frame_rect.width
            local img_unit_h: integer = sprite.sprite_sheet.height // sprite.frame_rect.height

            sprite.frame_rect.x = (sprite.frame_index % img_unit_w) * sprite.frame_rect.width
            sprite.frame_rect.y = (sprite.frame_index // img_unit_w) * sprite.frame_rect.height

            Raylib.DrawTextureRec(sprite.sprite_sheet, sprite.frame_rect, position.position, WHITE)
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global Animation = @record{
   system: System
}

function Animation.new(): Animation
   local new_system: Animation = {
      system = {
         read = {},
         write = {bitset_array.copy(component_masks.animations), bitset_array.copy(component_masks.sprite)}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function Animation:run(animations_storage: Storage(Animations)*, sprite_storage: Storage(Sprite)*, dt: number)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local animations_id = ids[0]
         local sprite_id = ids[1]

         local opt_animations = animations_storage:get_entry(animations_id)
         local opt_sprite = sprite_storage:get_entry(sprite_id)

         if opt_animations.filled and opt_sprite.filled then
            local animations = opt_animations:get()
            local sprite = opt_sprite:get()

            if not animations.paused then
               animations.elapsed_time = animations.elapsed_time + dt
               local current_animation: AnimationData* = animations.animations[animations.current_animation_index]

               if animations.elapsed_time > current_animation.frame_duration then
                  animations.current_frame_index = (animations.current_frame_index + 1) % #current_animation.frame_indexes
                  animations.elapsed_time = 0
               end

               sprite.frame_index = current_animation.frame_indexes[animations.current_frame_index]
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global ShowCollisions = @record{
   system: System
}

function ShowCollisions.new(): ShowCollisions
   local new_system: ShowCollisions = {
      system = {
         read = {bitset_array.copy(component_masks.collisions), bitset_array.copy(component_masks.collider)},
         write = {}
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function ShowCollisions:run(collisions_storage: Storage(Collisions)*, collider_storage: Storage(Collider)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local collisions_id = ids[0]
         local collider_id = ids[1]

         local opt_collisions = collisions_storage:get_entry(collisions_id)
         local opt_collider = collider_storage:get_entry(collider_id)

         if opt_collisions.filled and opt_collider.filled then
            local collisions = opt_collisions:get()
            local collider = opt_collider:get()

            Raylib.DrawRectangleLinesEx(collider.global_rect, 1, GREEN)

            for j = 0, < #collisions.intersections do
               local intersection: Intersection* = collisions.intersections[j]
               local rect_color: Color = intersection.state == CollisionState.Enter and BLUE or RED
               Raylib.DrawRectangleLinesEx(intersection.rect, 1, rect_color)
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global CollisionDetection = @record{
   system: System
}

local function is_past_collision(intersections: vector(Intersection)*, collider: Collider*): integer
   for i = 0, < #intersections do
      if intersections[i].collider.entity_id == collider.entity_id then
         return i
      end
   end
   return -1
end

function CollisionDetection.new(): CollisionDetection
   local new_system: CollisionDetection = {
      system = {
         read = {bitset_array.copy(component_masks.collider)},
         write = {bitset_array.copy(component_masks.collisions)},
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function CollisionDetection:run(collider_storage: Storage(Collider)*, collisions_storage: Storage(Collisions)*)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local collider_id = ids[0]
         local collisions_id = ids[1]

         local opt_collider = collider_storage:get_entry(collider_id)
         local opt_collisions = collisions_storage:get_entry(collisions_id)

         if opt_collider.filled  and opt_collisions.filled then
            local collider = opt_collider:get()
            local collisions = opt_collisions:get()

            for j = 0, < collider_storage.len do
               if collider_storage.generations[j].filled then
                  local collider_j = collider_storage.entries[j]

                  if collider.entity_id ~= collider_j.entity_id then
                     local has_collision = Raylib.CheckCollisionRecs(collider.global_rect, collider_j.global_rect)
                     local possible_past_collision = is_past_collision(collisions.intersections, collider_j)

                     if has_collision then
                        local intersection_rect = Raylib.GetCollisionRec(collider.global_rect, collider_j.global_rect)

                        if possible_past_collision >= 0 then
                           collisions.intersections[possible_past_collision].state = CollisionState.Stay
                           collisions.intersections[possible_past_collision].rect = intersection_rect
                        else
                           local new_intersection: Intersection = {
                              collider = collider_j,
                              rect = intersection_rect,
                              state = CollisionState.Enter
                           }
                           collisions.intersections:push(new_intersection)
                        end
                     elseif possible_past_collision >= 0 then
                        collisions.intersections:remove(possible_past_collision)
                     end
                  end
               end
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end

global PlayerController = @record{
   system: System
}

function PlayerController.new(): PlayerController
   local new_system: PlayerController = {
      system = {
         read = {
            bitset_array.copy(component_masks.player),
            bitset_array.copy(component_masks.collisions),
         },
         write = {
            bitset_array.copy(component_masks.velocity),
         }
      }
   }

   new_system.system.system_data = SystemData.new(new_system.system.read, new_system.system.write)
   return new_system
end

function PlayerController:run(
   player_storage: Storage(Player)*,
   collisions_storage: Storage(Collisions)*,
   velocity_storage: Storage(Velocity)*,
   player_input: PlayerInput
)
   for i = 0, < #self.system.system_data.components_indexes do
      local ids = self.system.system_data.components_indexes[i]

      if #ids > 0 then
         local player_id = ids[0]
         local collisions_id = ids[1]
         local velocity_id = ids[2]

         local opt_player = player_storage:get_entry(player_id)
         local opt_collisions = collisions_storage:get_entry(collisions_id)
         local opt_velocity = velocity_storage:get_entry(velocity_id)

         if opt_player.filled and opt_collisions.filled and opt_velocity.filled then
            local player = opt_player:get()
            local collisions = opt_collisions:get()
            local velocity = opt_velocity:get()

            if #collisions.intersections > 0 then
               for j = 0, < #collisions.intersections do
                  local intersection = &collisions.intersections[j]

                  -- if didn't intersected with a obstacle entity
                  if intersection.collider.entity_tag & player.walkstop_mask == 0 then
                     velocity.direction = player_input.direction
                  else
                     local dir: Vector2 = intersection:get_direction(intersection:get_center(), 2)
                     local dir_x_inputdir = dir * player_input.direction

                     velocity.direction.x = dir_x_inputdir.x > 0 and player_input.direction.x or 0
                     velocity.direction.y = dir_x_inputdir.y > 0 and player_input.direction.y or 0
                  end
               end
            else
               velocity.direction = player_input.direction
            end
         else
            self.system.system_data:mark_available(i)
         end
      end
   end
end
-- ] systems ]



