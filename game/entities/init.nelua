require 'math'
require 'vector'
require 'raylib'
require 'rotor'
require 'game.components'
require 'game.resources'
require 'rotor-quick.makers'

##[[
   -- the entity maker will render the returned string using name replacement ( #||# )
   local get_var_field_codestr = require ('rotor-quick.metalib').get_var_field_codestr

   local ent_pp_quick = {
      storages = {
         entity = get_var_field_codestr(storages, 'entity'),
         player = get_var_field_codestr(storages, 'player'),
         gear = get_var_field_codestr(storages, 'gear'),
         gear_slot = get_var_field_codestr(storages, 'gear_slot'),
         bridge = get_var_field_codestr(storages, 'bridge'),
         box = get_var_field_codestr(storages, 'box'),
         position = get_var_field_codestr(storages, 'position'),
         velocity = get_var_field_codestr(storages, 'velocity'),
         collider = get_var_field_codestr(storages, 'collider'),
         collisions = get_var_field_codestr(storages, 'collisions'),
         sprite = get_var_field_codestr(storages, 'sprite'),
         animations = get_var_field_codestr(storages, 'animations'),
         obstacles = get_var_field_codestr(storages, 'obstacles'),
      },
      masks = {
         entity = get_var_field_codestr(component_masks, 'entity'),
         player = get_var_field_codestr(component_masks, 'player'),
         gear = get_var_field_codestr(component_masks, 'gear'),
         gear_slot = get_var_field_codestr(component_masks, 'gear_slot'),
         bridge = get_var_field_codestr(component_masks, 'bridge'),
         box = get_var_field_codestr(component_masks, 'box'),
         position = get_var_field_codestr(component_masks, 'position'),
         velocity = get_var_field_codestr(component_masks, 'velocity'),
         collider = get_var_field_codestr(component_masks, 'collider'),
         collisions = get_var_field_codestr(component_masks, 'collisions'),
         sprite = get_var_field_codestr(component_masks, 'sprite'),
         animations = get_var_field_codestr(component_masks, 'animations'),
         obstacles = get_var_field_codestr(component_masks, 'obstacles'),
      }
   }
]]

global PlayerEntity = #[make_entity{
   {'player'    , Player    , ent_pp_quick.storages.player    , ent_pp_quick.masks.player},
   {'position'  , Position  , ent_pp_quick.storages.position  , ent_pp_quick.masks.position},
   {'velocity'  , Velocity  , ent_pp_quick.storages.velocity  , ent_pp_quick.masks.velocity},
   {'obstacles' , Obstacles , ent_pp_quick.storages.obstacles , ent_pp_quick.masks.obstacles},
   {'collider'  , Collider  , ent_pp_quick.storages.collider  , ent_pp_quick.masks.collider},
   {'collisions', Collisions, ent_pp_quick.storages.collisions, ent_pp_quick.masks.collisions},
   {'sprite'    , Sprite    , ent_pp_quick.storages.sprite    , ent_pp_quick.masks.sprite},
   {'animations', Animations, ent_pp_quick.storages.animations, ent_pp_quick.masks.animations}
}]#

function PlayerEntity.create(pos: Vector2): PlayerEntity
   local pl_collider: Collider = {
      local_rect = { 8, 16 - 32, 16, 16},
      global_rect = { 8, 16 - 32, 16, 16},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Player
   }

   local pl_sprite: Sprite = {
      sprite_sheet = resources.princess_spritesheet,
      frame_index = 0,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local pl_animations: Animations = {
      animations = {
         --[[0 idle  ]] { frame_indexes = {  0,  1,  2,  3 }, frame_duration = 0.2 },
         --[[1 D-walk]] { frame_indexes = {  6,  7,  8,  9, 10, 11 }, frame_duration = 0.1 },
         --[[2 U-walk]] { frame_indexes = { 12, 13, 14, 15, 16, 17 }, frame_duration = 0.1 },
         --[[3 R-walk]] { frame_indexes = { 18, 19, 20, 21, 22, 23 }, frame_duration = 0.1 },
         --[[4 L-walk]] { frame_indexes = { 24, 25, 26, 27, 28, 29 }, frame_duration = 0.1 },
         --[[5 D-push]] { frame_indexes = { 30, 31, 32, 33, 34, 35 }, frame_duration = 0.2 },
         --[[6 U-push]] { frame_indexes = { 36, 37, 38, 39, 40, 41 }, frame_duration = 0.2 },
         --[[7 R-push]] { frame_indexes = { 42, 43, 44, 45, 46, 47 }, frame_duration = 0.2 },
         --[[8 L-push]] { frame_indexes = { 48, 49, 50, 51, 52, 53 }, frame_duration = 0.2 },
      },
      current_animation_index = 0,
      current_frame_index = 0,
      elapsed_time = 0,
      paused = false
   }

   local player_entity, entity = PlayerEntity.new(
      storages.entity,
      {
         --[[player]]     {},
         --[[position]]   { position = pos },
         --[[velocity]]   { direction = { 0, 0 }, speed = #[PL_VEL]# },
         --[[obstacles]]  { mask = EntityTag.Wall | EntityTag.Box | EntityTag.Gear | EntityTag.GearSlot | EntityTag.ClosedBridge },
         --[[collider]]   pl_collider,
         --[[collisions]] {},
         --[[sprite]]     pl_sprite,
         --[[animations]] pl_animations
      }
   )

   local position = player_entity:get_position(storages.position)
   local collider = player_entity:get_collider(storages.collider)

   collider.entity_id = player_entity.entity_id
   collider:sync_with_position(position.position)

   Game_Systems:update_all(entity)

   return player_entity
end

global WallEntity = #[make_entity{
   {'position', Position, ent_pp_quick.storages.position, ent_pp_quick.masks.position},
   {'collider', Collider, ent_pp_quick.storages.collider, ent_pp_quick.masks.collider},
   {'sprite'  , Sprite  , ent_pp_quick.storages.sprite  , ent_pp_quick.masks.sprite},
}]#

function WallEntity.create(pos: Vector2, fi: uinteger, col: Rectangle, offset_mul: integer): WallEntity
   local _col: Rectangle = {
      col.x, col.y - 32 * offset_mul,
      col.width, col.height
   }

   local wall_collider: Collider = {
      local_rect = _col,
      global_rect = _col,
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Wall
   }

   local wall_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = fi,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 * offset_mul },
      visible = true,
   }

   local wall_entity, entity = WallEntity.new(
      storages.entity,
      {
      --[[position]] { position = pos },
      --[[collider]] wall_collider,
      --[[sprite]]   wall_sprite,
      }
   )

   local position = wall_entity:get_position(storages.position)
   local collider = wall_entity:get_collider(storages.collider)

   collider.entity_id = wall_entity.entity_id
   collider:sync_with_position(position.position)

   Game_Systems:update_all(entity)

   return wall_entity
end

global BoxEntity = #[make_entity{
   {'box'       , Box       , ent_pp_quick.storages.box       , ent_pp_quick.masks.box},
   {'position'  , Position  , ent_pp_quick.storages.position  , ent_pp_quick.masks.position},
   {'velocity'  , Velocity  , ent_pp_quick.storages.velocity  , ent_pp_quick.masks.velocity},
   {'obstacles' , Obstacles , ent_pp_quick.storages.obstacles , ent_pp_quick.masks.obstacles},
   {'collider'  , Collider  , ent_pp_quick.storages.collider  , ent_pp_quick.masks.collider},
   {'collisions', Collisions, ent_pp_quick.storages.collisions, ent_pp_quick.masks.collisions},
   {'sprite'    , Sprite    , ent_pp_quick.storages.sprite    , ent_pp_quick.masks.sprite},
}]#

function BoxEntity.create(pos: Vector2, fi: uinteger): BoxEntity
   local box_collider: Collider = {
      local_rect = { 0, 12 - 32, 32, 20},
      global_rect = { 0, 12 - 32, 32, 20},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Box
   }

   local box_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = fi,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local box_entity, entity = BoxEntity.new(
      storages.entity,
      {
      --[[box]]        {},
      --[[position]]   { position = pos },
      --[[velocity]]   { direction = { 0, 0 }, speed = #[PL_VEL]# },
      --[[obstacles]]  { mask = EntityTag.Wall | EntityTag.Player | EntityTag.Gear | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]]   box_collider,
      --[[collisions]] {},
      --[[sprite]]     box_sprite
      }
   )

   local position = box_entity:get_position(storages.position)
   local collider = box_entity:get_collider(storages.collider)

   collider.entity_id = box_entity.entity_id
   collider:sync_with_position(position.position)

   Game_Systems:update_all(entity)

   return box_entity
end

global GearEntity = #[make_entity{
   {'gear'      , Gear      , ent_pp_quick.storages.gear      , ent_pp_quick.masks.gear},
   {'position'  , Position  , ent_pp_quick.storages.position  , ent_pp_quick.masks.position},
   {'velocity'  , Velocity  , ent_pp_quick.storages.velocity  , ent_pp_quick.masks.velocity},
   {'obstacles' , Obstacles , ent_pp_quick.storages.obstacles , ent_pp_quick.masks.obstacles},
   {'collider'  , Collider  , ent_pp_quick.storages.collider  , ent_pp_quick.masks.collider},
   {'collisions', Collisions, ent_pp_quick.storages.collisions, ent_pp_quick.masks.collisions},
   {'sprite'    , Sprite    , ent_pp_quick.storages.sprite    , ent_pp_quick.masks.sprite},
   {'animations', Animations, ent_pp_quick.storages.animations, ent_pp_quick.masks.animations},
}]#

function GearEntity.create(pos: Vector2): GearEntity
   local gear_collider: Collider = {
      local_rect = { 0, -32, 32, 32},
      global_rect = { 0, -32, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Gear
   }

   local gear_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 16,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -33 },
      visible = true,
   }

   local gear_animations: Animations = {
      animations = {
         --[[horizontal]] { frame_indexes = { 16, 16, 16 }, frame_duration = 0.1 },
         --[[vertical  ]] { frame_indexes = { 18, 28, 38 }, frame_duration = 0.1 },
         --[[engaged   ]] { frame_indexes = { 27, 27, 27 }, frame_duration = 0.1 }
      },
      current_animation_index = 0,
      current_frame_index = 0,
      elapsed_time = 0,
      paused = true
   }

   local gear_entity, entity = GearEntity.new(
      storages.entity,
      {
      --[[gear]]       { engaged = false },
      --[[position]]   { position = pos },
      --[[velocity]]   { direction = { 0, 0 }, speed = 2 },
      --[[obstacles]]  { mask = EntityTag.Wall | EntityTag.Box | EntityTag.Player | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]]   gear_collider,
      --[[collisions]] {},
      --[[sprite]]     gear_sprite,
      --[[animations]] gear_animations,
      }
   )

   local position = gear_entity:get_position(storages.position)
   local collider = gear_entity:get_collider(storages.collider)

   collider.entity_id = gear_entity.entity_id
   collider:sync_with_position(position.position)

   Game_Systems:update_all(entity)

   return gear_entity
end

global GearSlotEntity = #[make_entity{
   {'gear_slot' , GearSlot  , ent_pp_quick.storages.gear_slot , ent_pp_quick.masks.gear_slot},
   {'position'  , Position  , ent_pp_quick.storages.position  , ent_pp_quick.masks.position},
   {'collider'  , Collider  , ent_pp_quick.storages.collider  , ent_pp_quick.masks.collider},
   {'collisions', Collisions, ent_pp_quick.storages.collisions, ent_pp_quick.masks.collisions},
   {'sprite'    , Sprite    , ent_pp_quick.storages.sprite    , ent_pp_quick.masks.sprite},
}]#

function GearSlotEntity.create(pos: Vector2, slot_idx: uinteger): GearSlotEntity
   local gear_slot_collider: Collider = {
      local_rect = { 0, -32, 32, 32},
      global_rect = { 0, -23, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.GearSlot
   }

   local gear_slot_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 26,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local gear_slot_entity, entity = GearSlotEntity.new(
      storages.entity,
      {
      --[[gear_slot]] { slot_idx = slot_idx},
      --[[position]]  { position = pos },
      --[[collider]]  gear_slot_collider,
      --[[collisions]] {},
      --[[sprite]]    gear_slot_sprite,
      }
   )

   local position = gear_slot_entity:get_position(storages.position)
   local collider = gear_slot_entity:get_collider(storages.collider)

   collider.entity_id = gear_slot_entity.entity_id
   collider:sync_with_position(position.position)

   Game_Systems:update_all(entity)

   return gear_slot_entity
end

global BridgeEntity = #[make_entity{
   {'bridge'    , Bridge    , ent_pp_quick.storages.bridge    , ent_pp_quick.masks.bridge},
   {'position'  , Position  , ent_pp_quick.storages.position  , ent_pp_quick.masks.position},
   {'collider'  , Collider  , ent_pp_quick.storages.collider  , ent_pp_quick.masks.collider},
   {'collisions', Collisions, ent_pp_quick.storages.collisions, ent_pp_quick.masks.collisions},
   {'sprite'    , Sprite    , ent_pp_quick.storages.sprite    , ent_pp_quick.masks.sprite},
}]#

function BridgeEntity.create(pos: Vector2, slot_idx: uinteger): BridgeEntity
   local bridge_collider: Collider = {
      local_rect = { 0, 0, 32, 32},
      global_rect = { 0, 0, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.ClosedBridge
   }

   local bridge_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 9 + math.random(0 , 1) * 10, -- random: 9 or 19
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, 0 },
      visible = false,
   }

   local bridge_entity, entity = BridgeEntity.new(
      storages.entity,
      {
      --[[bridge]]     { slot_idx = slot_idx },
      --[[position]]   { position = pos },
      --[[collider]]   bridge_collider,
      --[[collisions]] {},
      --[[sprite]]     bridge_sprite,
      }
   )

   local position = bridge_entity:get_position(storages.position)
   local collider = bridge_entity:get_collider(storages.collider)

   collider.entity_id = bridge_entity.entity_id
   collider:sync_with_position(position.position)

   Game_Systems:update_all(entity)

   return bridge_entity
end
