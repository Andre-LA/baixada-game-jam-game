require 'math'
require 'vector'
require 'raylib'
require 'rotor'
require 'game.components'
require 'game.resources'

global PlayerEntity = @record{
   entity_id: GenerationalIndex,
   player_id: GenerationalIndex,
   position_id: GenerationalIndex,
   velocity_id: GenerationalIndex,
   obstacles_id: GenerationalIndex,
   collider_id: GenerationalIndex,
   collisions_id: GenerationalIndex,
   sprite_id: GenerationalIndex,
   animations_id: GenerationalIndex,
}

function PlayerEntity.new(
   entity_storage: Storage(Entity)*,
   player_vl: Player,
   position_vl: Position,
   velocity_vl: Velocity,
   obstacles_vl: Obstacles,
   collider_vl: Collider,
   sprite_vl: Sprite,
   animations_vl: Animations,
   untracked_ids: vector(GenerationalIndex)*
): PlayerEntity
   local entity_id, entity = entity_storage:new_entry(Entity.new())

   --player_vl.start_position = position_vl.position

   local player_id, player = Player.associate(player_vl, entity)
   local position_id, position = Position.associate(position_vl, entity)
   local velocity_id, velocity = Velocity.associate(velocity_vl, entity)
   local obstacles_id, obstacles = Obstacles.associate(obstacles_vl, entity)

   collider_vl.entity_id = entity_id
   collider_vl:sync_with_position(position_vl.position)
   local collider_id, collider = Collider.associate(collider_vl, entity)
   local collisions_id, collisions = Collisions.associate({{}}, entity)
   local sprite_id, sprite = Sprite.associate(sprite_vl, entity)
   local animations_id, animations = Animations.associate(animations_vl, entity)

   untracked_ids:push(entity_id)

   return (@PlayerEntity){
      entity_id = entity_id,
      player_id = player_id,
      position_id = position_id,
      velocity_id = velocity_id,
      obstacles_id = obstacles_id,
      collider_id = collider_id,
      collisions_id = collisions_id,
      sprite_id = sprite_id,
      animations_id = animations_id,
   }
end

function PlayerEntity.create(pos: Vector2, untracked_ids: vector(GenerationalIndex)*): PlayerEntity
   local pl_collider: Collider = {
      local_rect = { 8, 16 - 32, 16, 16},
      global_rect = { 8, 16 - 32, 16, 16},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Player
   }

   local pl_sprite: Sprite = {
      sprite_sheet = resources.princess_spritesheet,
      frame_index = 0,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local pl_animations: Animations = {
      animations = {
         --[[0 idle  ]] { frame_indexes = {  0,  1,  2,  3 }, frame_duration = 0.2 },
         --[[1 D-walk]] { frame_indexes = {  6,  7,  8,  9, 10, 11 }, frame_duration = 0.2 },
         --[[2 U-walk]] { frame_indexes = { 12, 13, 14, 15, 16, 17 }, frame_duration = 0.2 },
         --[[3 R-walk]] { frame_indexes = { 18, 19, 20, 21, 22, 23 }, frame_duration = 0.2 },
         --[[4 L-walk]] { frame_indexes = { 24, 25, 26, 27, 28, 29 }, frame_duration = 0.2 },
         --[[5 D-push]] { frame_indexes = { 30, 31, 32, 33, 34, 35 }, frame_duration = 0.2 },
         --[[6 U-push]] { frame_indexes = { 36, 37, 38, 39, 40, 41 }, frame_duration = 0.2 },
         --[[7 R-push]] { frame_indexes = { 42, 43, 44, 45, 46, 47 }, frame_duration = 0.2 },
         --[[8 L-push]] { frame_indexes = { 48, 49, 50, 51, 52, 53 }, frame_duration = 0.2 },
      },
      current_animation_index = 0,
      current_frame_index = 0,
      elapsed_time = 0,
      paused = false
   }

   return PlayerEntity.new(
      storages.entity,
      --[[player]]     {},
      --[[position]]   { position = pos },
      --[[velocity]]   { direction = { 0, 0 }, speed = #[PL_VEL]# },
      --[[obstacles]]  { EntityTag.Wall | EntityTag.Box | EntityTag.Gear | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]]   pl_collider,
      --[[sprite]]     pl_sprite,
      --[[animations]] pl_animations,
      untracked_ids
   )
end

global WallEntity = @record{
   entity_id: GenerationalIndex,
   position_id: GenerationalIndex,
   collider_id: GenerationalIndex,
   sprite_id: GenerationalIndex,
}

function WallEntity.new(
   entity_storage: Storage(Entity)*,
   position_vl: Position,
   collider_vl: Collider,
   sprite_vl: Sprite,
   untracked_ids: vector(GenerationalIndex)*
): WallEntity
   local entity_id, entity = entity_storage:new_entry(Entity.new())
   local position_id, position = Position.associate(position_vl, entity)

   collider_vl.entity_id = entity_id
   collider_vl:sync_with_position(position_vl.position)
   local collider_id, collider = Collider.associate(collider_vl, entity)

   local sprite_id, sprite = Sprite.associate(sprite_vl, entity)

   untracked_ids:push(entity_id)

   return (@WallEntity){
      entity_id = entity_id,
      position_id = position_id,
      collider_id = collider_id,
      sprite_id = sprite_id,
   }
end

function WallEntity.create(
   pos: Vector2,
   fi: uinteger,
   col: Rectangle,
   offset_mul: integer,
   untracked_ids: vector(GenerationalIndex)*
): WallEntity
   local _col: Rectangle = {
      col.x, col.y - 32 * offset_mul,
      col.width, col.height
   }

   local wall_collider: Collider = {
      local_rect = _col,
      global_rect = _col,
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Wall
   }

   local wall_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = fi,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 * offset_mul },
      visible = true,
   }

   return WallEntity.new(
      storages.entity,
      --[[position]] { position = pos },
      --[[collider]] wall_collider,
      --[[sprite]]   wall_sprite,
      untracked_ids
   )
end

global BoxEntity = @record{
   entity_id: GenerationalIndex,
   box_id: GenerationalIndex,
   position_id: GenerationalIndex,
   velocity_id: GenerationalIndex,
   obstacles_id: GenerationalIndex,
   collider_id: GenerationalIndex,
   collisions_id: GenerationalIndex,
   sprite_id: GenerationalIndex,
}

function BoxEntity.new(
   entity_storage: Storage(Entity)*,
   box_vl: Box,
   position_vl: Position,
   velocity_vl: Velocity,
   obstacles_vl: Obstacles,
   collider_vl: Collider,
   sprite_vl: Sprite,
   untracked_ids: vector(GenerationalIndex)*
): BoxEntity
   local entity_id, entity = entity_storage:new_entry(Entity.new())

   box_vl.start_position = position_vl.position

   local box_id, box = Box.associate(box_vl, entity)
   local position_id, position = Position.associate(position_vl, entity)
   local velocity_id, velocity = Velocity.associate(velocity_vl, entity)
   local obstacles_id, obstacles = Obstacles.associate(obstacles_vl, entity)

   collider_vl.entity_id = entity_id
   collider_vl:sync_with_position(position_vl.position)
   local collider_id, collider = Collider.associate(collider_vl, entity)

   local collisions_id, collisions = Collisions.associate({{}}, entity)
   local sprite_id, sprite = Sprite.associate(sprite_vl, entity)

   untracked_ids:push(entity_id)

   return (@BoxEntity){
      entity_id = entity_id,
      box_id = box_id,
      position_id = position_id,
      velocity_id = velocity_id,
      obstacles_id = obstacles_id,
      collider_id = collider_id,
      collisions_id = collisions_id,
      sprite_id = sprite_id,
   }
end

function BoxEntity.create(pos: Vector2, fi: uinteger, untracked_ids: vector(GenerationalIndex)*): BoxEntity
   local box_collider: Collider = {
      local_rect = { 0, 12 - 32, 32, 20},
      global_rect = { 0, 12 - 32, 32, 20},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Box
   }

   local box_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = fi,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   return BoxEntity.new(
      storages.entity,
      --[[box]]      {},
      --[[position]] { position = pos },
      --[[velocity]] { direction = { 0, 0 }, speed = #[PL_VEL]# },
      --[[obstacles]] { mask = EntityTag.Wall | EntityTag.Player | EntityTag.Gear | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]] box_collider,
      --[[sprite]]   box_sprite,
      untracked_ids
   )
end

global GearEntity = @record{
   entity_id: GenerationalIndex,
   gear_id: GenerationalIndex,
   position_id: GenerationalIndex,
   velocity_id: GenerationalIndex,
   obstacles_id: GenerationalIndex,
   collider_id: GenerationalIndex,
   collisions_id: GenerationalIndex,
   sprite_id: GenerationalIndex,
   animations_id: GenerationalIndex,
}

function GearEntity.new(
   entity_storage: Storage(Entity)*,
   gear_vl: Gear,
   position_vl: Position,
   velocity_vl: Velocity,
   obstacles_vl: Obstacles,
   collider_vl: Collider,
   sprite_vl: Sprite,
   animations_vl: Animations,
   untracked_ids: vector(GenerationalIndex)*
): GearEntity
   local entity_id, entity = entity_storage:new_entry(Entity.new())

   gear_vl.start_position = position_vl.position

   local gear_id, gear = Gear.associate(gear_vl, entity)
   local position_id, position = Position.associate(position_vl, entity)
   local velocity_id, velocity = Velocity.associate(velocity_vl, entity)
   local obstacles_id, obstacles = Obstacles.associate(obstacles_vl, entity)

   collider_vl.entity_id = entity_id
   collider_vl:sync_with_position(position_vl.position)
   local collider_id, collider = Collider.associate(collider_vl, entity)

   local collisions_id, collisions = Collisions.associate({{}}, entity)
   local sprite_id, sprite = Sprite.associate(sprite_vl, entity)
   local animations_id, animations = Animations.associate(animations_vl, entity)

   untracked_ids:push(entity_id)

   return (@GearEntity){
      entity_id = entity_id,
      gear_id = gear_id,
      position_id = position_id,
      velocity_id = velocity_id,
      obstacles_id = obstacles_id,
      collider_id = collider_id,
      collisions_id = collisions_id,
      sprite_id = sprite_id,
      animations_id = animations_id,
   }
end

function GearEntity.create(pos: Vector2, untracked_ids: vector(GenerationalIndex)*): GearEntity
   local gear_collider: Collider = {
      local_rect = { 0, -32, 32, 32},
      global_rect = { 0, -32, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Gear
   }

   local gear_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 16,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -33 },
      visible = true,
   }

   local gear_animations: Animations = {
      animations = {
         --[[horizontal]] { frame_indexes = { 16, 16, 16 }, frame_duration = 0.1 },
         --[[vertical  ]] { frame_indexes = { 18, 28, 38 }, frame_duration = 0.1 },
         --[[engaged   ]] { frame_indexes = { 27, 27, 27 }, frame_duration = 0.1 }
      },
      current_animation_index = 0,
      current_frame_index = 0,
      elapsed_time = 0,
      paused = true
   }

   return GearEntity.new(
      storages.entity,
      --[[gear]]       { engaged = false },
      --[[position]]   { position = pos },
      --[[velocity]]   { direction = { 0, 0 }, speed = 2 },
      --[[obstacles]]  { mask = EntityTag.Wall | EntityTag.Box | EntityTag.Player | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]]   gear_collider,
      --[[sprite]]     gear_sprite,
      --[[animations]] gear_animations,
      untracked_ids
   )
end

global GearSlotEntity = @record{
   entity_id: GenerationalIndex,
   gear_slot_id: GenerationalIndex,
   position_id: GenerationalIndex,
   collider_id: GenerationalIndex,
   collisions_id: GenerationalIndex,
   sprite_id: GenerationalIndex,
}

function GearSlotEntity.new(
   entity_storage: Storage(Entity)*,
   gear_slot_vl: GearSlot,
   position_vl: Position,
   velocity_vl: Velocity,
   collider_vl: Collider,
   sprite_vl: Sprite,
   untracked_ids: vector(GenerationalIndex)*
): GearSlotEntity
   local entity_id, entity = entity_storage:new_entry(Entity.new())
   local gear_slot_id, gear_slot = GearSlot.associate(gear_slot_vl, entity)
   local position_id, position = Position.associate(position_vl, entity)

   collider_vl.entity_id = entity_id
   collider_vl:sync_with_position(position_vl.position)
   local collider_id, collider = Collider.associate(collider_vl, entity)

   local collisions_id, collisions = Collisions.associate({{}}, entity)
   local sprite_id, sprite = Sprite.associate(sprite_vl, entity)

   untracked_ids:push(entity_id)

   return (@GearSlotEntity){
      entity_id = entity_id,
      gear_slot_id = gear_slot_id,
      position_id = position_id,
      collider_id = collider_id,
      collisions_id = collisions_id,
      sprite_id = sprite_id,
   }
end

function GearSlotEntity.create(pos: Vector2, slot_idx: uinteger, untracked_ids: vector(GenerationalIndex)*): GearSlotEntity
   local gear_slot_collider: Collider = {
      local_rect = { 0, -32, 32, 32},
      global_rect = { 0, -23, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.GearSlot
   }

   local gear_slot_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 26,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   return GearSlotEntity.new(
      storages.entity,
      --[[gear_slot]] { slot_idx = slot_idx},
      --[[position]]  { position = pos },
      --[[velocity]]  { direction = { 0, 0 }, speed = 2 },
      --[[collider]]  gear_slot_collider,
      --[[sprite]]    gear_slot_sprite,
      untracked_ids
   )
end

global BridgeEntity = @record{
   entity_id: GenerationalIndex,
   bridge_id: GenerationalIndex,
   position_id: GenerationalIndex,
   collider_id: GenerationalIndex,
   collisions_id: GenerationalIndex,
   sprite_id: GenerationalIndex,
}

function BridgeEntity.new(
   entity_storage: Storage(Entity)*,
   bridge_vl: Bridge,
   position_vl: Position,
   velocity_vl: Velocity,
   collider_vl: Collider,
   sprite_vl: Sprite,
   untracked_ids: vector(GenerationalIndex)*
): BridgeEntity
   local entity_id, entity = entity_storage:new_entry(Entity.new())
   local bridge_id, bridge = Bridge.associate(bridge_vl, entity)
   local position_id, position = Position.associate(position_vl, entity)

   collider_vl.entity_id = entity_id
   collider_vl:sync_with_position(position_vl.position)
   local collider_id, collider = Collider.associate(collider_vl, entity)

   local collisions_id, collisions = Collisions.associate({{}}, entity)
   local sprite_id, sprite = Sprite.associate(sprite_vl, entity)

   untracked_ids:push(entity_id)

   return (@BridgeEntity){
      entity_id = entity_id,
      bridge_id = bridge_id,
      position_id = position_id,
      collider_id = collider_id,
      collisions_id = collisions_id,
      sprite_id = sprite_id,
   }
end

function BridgeEntity.create(pos: Vector2, slot_idx: uinteger, untracked_ids: vector(GenerationalIndex)*): BridgeEntity
   local bridge_collider: Collider = {
      local_rect = { 0, 0, 32, 32},
      global_rect = { 0, 0, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.ClosedBridge
   }

   local bridge_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 9 + math.random(0 , 1) * 10, -- random: 9 or 19
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, 0 },
      visible = false,
   }

   return BridgeEntity.new(
      storages.entity,
      --[[bridge]]   { slot_idx = slot_idx },
      --[[position]] { position = pos },
      --[[velocity]] { direction = { 0, 0 }, speed = 2 },
      --[[collider]] bridge_collider,
      --[[sprite]]   bridge_sprite,
      untracked_ids
   )
end
