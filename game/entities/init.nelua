require 'math'
require 'vector'
require 'raylib'
require 'rotor'
require 'game.components'
require 'game.resources'

## local make_entity = hygienize(function(...)
   ##[[
      local metalib = require 'metalib'
      local component_names, component_types = metalib.collect_doubles(1, -1, ...)
   ]]##

   local new_entity = @record{ entity_id: GenerationalIndex }
   local VlCollection = @record{}

   ## for i, name in ipairs(component_names) do
      ## new_entity.value:add_field(name .. '_id', GenerationalIndex.value)

      ## local _type = component_types[i].value
      ## staticassert(traits.is_type(_type), "invalid type %s", _type)

      ## VlCollection.value:add_field(name .. '_vl', _type)

      function new_entity:#|'get_'..name|#(storage: Storage(#[_type]#)*): pointer(#[_type]#)
         local possible_result = storage:get_entry(self.#|name..'_id'|#)
         check(possible_result.filled, #[name .. ' is not associated with entity!']#)
         local result = possible_result:get()
         return result
      end
   ## end

   function new_entity.new(entity_storage: Storage(Entity)*, values: VlCollection, untracked_ids: vector(GenerationalIndex)*): new_entity
      local result: new_entity = {}

      local entity_id, entity = entity_storage:new_entry(Entity.new())
      result.entity_id = entity_id

      ## for i, name in ipairs(component_names) do
         ## local _type = component_types[i]
         ## local name_id = name..'_id'

         local #|name_id|#, #|name|# = #[_type]#.associate(values.#|name..'_vl'|#, entity)
         result.#|name_id|# = #|name_id|#
      ## end

      untracked_ids:push(entity_id)

      return result
   end

   ## return new_entity
## end)

global PlayerEntity = #[ make_entity(
   'player', Player,
   'position', Position,
   'velocity', Velocity,
   'obstacles', Obstacles,
   'collider', Collider,
   'collisions', Collisions,
   'sprite', Sprite,
   'animations', Animations
)]#

function PlayerEntity.create(pos: Vector2, untracked_ids: vector(GenerationalIndex)*): PlayerEntity
   local pl_collider: Collider = {
      local_rect = { 8, 16 - 32, 16, 16},
      global_rect = { 8, 16 - 32, 16, 16},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Player
   }

   local pl_sprite: Sprite = {
      sprite_sheet = resources.princess_spritesheet,
      frame_index = 0,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local pl_animations: Animations = {
      animations = {
         --[[0 idle  ]] { frame_indexes = {  0,  1,  2,  3 }, frame_duration = 0.2 },
         --[[1 D-walk]] { frame_indexes = {  6,  7,  8,  9, 10, 11 }, frame_duration = 0.1 },
         --[[2 U-walk]] { frame_indexes = { 12, 13, 14, 15, 16, 17 }, frame_duration = 0.1 },
         --[[3 R-walk]] { frame_indexes = { 18, 19, 20, 21, 22, 23 }, frame_duration = 0.1 },
         --[[4 L-walk]] { frame_indexes = { 24, 25, 26, 27, 28, 29 }, frame_duration = 0.1 },
         --[[5 D-push]] { frame_indexes = { 30, 31, 32, 33, 34, 35 }, frame_duration = 0.2 },
         --[[6 U-push]] { frame_indexes = { 36, 37, 38, 39, 40, 41 }, frame_duration = 0.2 },
         --[[7 R-push]] { frame_indexes = { 42, 43, 44, 45, 46, 47 }, frame_duration = 0.2 },
         --[[8 L-push]] { frame_indexes = { 48, 49, 50, 51, 52, 53 }, frame_duration = 0.2 },
      },
      current_animation_index = 0,
      current_frame_index = 0,
      elapsed_time = 0,
      paused = false
   }

   local player_entity = PlayerEntity.new(
      storages.entity,
      {
         --[[player]]     {},
         --[[position]]   { position = pos },
         --[[velocity]]   { direction = { 0, 0 }, speed = #[PL_VEL]# },
         --[[obstacles]]  { EntityTag.Wall | EntityTag.Box | EntityTag.Gear | EntityTag.GearSlot | EntityTag.ClosedBridge },
         --[[collider]]   pl_collider,
         --[[collisions]] {},
         --[[sprite]]     pl_sprite,
         --[[animations]] pl_animations
      },
      untracked_ids
   )

   local position = player_entity:get_position(storages.position)
   local collider = player_entity:get_collider(storages.collider)

   collider.entity_id = player_entity.entity_id
   collider:sync_with_position(position.position)

   return player_entity
end

global WallEntity = #[make_entity(
   'position', Position,
   'collider', Collider,
   'sprite', Sprite
)]#

function WallEntity.create(
   pos: Vector2,
   fi: uinteger,
   col: Rectangle,
   offset_mul: integer,
   untracked_ids: vector(GenerationalIndex)*
): WallEntity
   local _col: Rectangle = {
      col.x, col.y - 32 * offset_mul,
      col.width, col.height
   }

   local wall_collider: Collider = {
      local_rect = _col,
      global_rect = _col,
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Wall
   }

   local wall_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = fi,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 * offset_mul },
      visible = true,
   }

   local wall_entity = WallEntity.new(
      storages.entity,
      {
      --[[position]] { position = pos },
      --[[collider]] wall_collider,
      --[[sprite]]   wall_sprite,
      },
      untracked_ids
   )

   local position = wall_entity:get_position(storages.position)
   local collider = wall_entity:get_collider(storages.collider)

   collider.entity_id = wall_entity.entity_id
   collider:sync_with_position(position.position)

   return wall_entity
end

global BoxEntity = #[make_entity(
   'box', Box,
   'position', Position,
   'velocity', Velocity,
   'obstacles', Obstacles,
   'collider', Collider,
   'collisions', Collisions,
   'sprite', Sprite
)]#

function BoxEntity.create(pos: Vector2, fi: uinteger, untracked_ids: vector(GenerationalIndex)*): BoxEntity
   local box_collider: Collider = {
      local_rect = { 0, 12 - 32, 32, 20},
      global_rect = { 0, 12 - 32, 32, 20},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Box
   }

   local box_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = fi,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local box_entity = BoxEntity.new(
      storages.entity,
      {
      --[[box]]        {},
      --[[position]]   { position = pos },
      --[[velocity]]   { direction = { 0, 0 }, speed = #[PL_VEL]# },
      --[[obstacles]]  { mask = EntityTag.Wall | EntityTag.Player | EntityTag.Gear | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]]   box_collider,
      --[[collisions]] {},
      --[[sprite]]     box_sprite
      },
      untracked_ids
   )

   local position = box_entity:get_position(storages.position)
   local collider = box_entity:get_collider(storages.collider)

   collider.entity_id = box_entity.entity_id
   collider:sync_with_position(position.position)

   return box_entity
end

global GearEntity = #[make_entity(
   'gear', Gear,
   'position', Position,
   'velocity', Velocity,
   'obstacles', Obstacles,
   'collider', Collider,
   'collisions', Collisions,
   'sprite', Sprite,
   'animations', Animations
)]#

function GearEntity.create(pos: Vector2, untracked_ids: vector(GenerationalIndex)*): GearEntity
   local gear_collider: Collider = {
      local_rect = { 0, -32, 32, 32},
      global_rect = { 0, -32, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.Gear
   }

   local gear_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 16,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -33 },
      visible = true,
   }

   local gear_animations: Animations = {
      animations = {
         --[[horizontal]] { frame_indexes = { 16, 16, 16 }, frame_duration = 0.1 },
         --[[vertical  ]] { frame_indexes = { 18, 28, 38 }, frame_duration = 0.1 },
         --[[engaged   ]] { frame_indexes = { 27, 27, 27 }, frame_duration = 0.1 }
      },
      current_animation_index = 0,
      current_frame_index = 0,
      elapsed_time = 0,
      paused = true
   }

   local gear_entity = GearEntity.new(
      storages.entity,
      {
      --[[gear]]       { engaged = false },
      --[[position]]   { position = pos },
      --[[velocity]]   { direction = { 0, 0 }, speed = 2 },
      --[[obstacles]]  { mask = EntityTag.Wall | EntityTag.Box | EntityTag.Player | EntityTag.GearSlot | EntityTag.ClosedBridge },
      --[[collider]]   gear_collider,
      --[[collisions]] {},
      --[[sprite]]     gear_sprite,
      --[[animations]] gear_animations,
      },
      untracked_ids
   )

   local position = gear_entity:get_position(storages.position)
   local collider = gear_entity:get_collider(storages.collider)

   collider.entity_id = gear_entity.entity_id
   collider:sync_with_position(position.position)

   return gear_entity
end

global GearSlotEntity = #[make_entity(
   'gear_slot', GearSlot,
   'position', Position,
   'collider', Collider,
   --'collisions', Collisions,
   'sprite', Sprite
)]#

function GearSlotEntity.create(pos: Vector2, slot_idx: uinteger, untracked_ids: vector(GenerationalIndex)*): GearSlotEntity
   local gear_slot_collider: Collider = {
      local_rect = { 0, -32, 32, 32},
      global_rect = { 0, -23, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.GearSlot
   }

   local gear_slot_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 26,
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, -32 },
      visible = true,
   }

   local gear_slot_entity = GearSlotEntity.new(
      storages.entity,
      {
      --[[gear_slot]] { slot_idx = slot_idx},
      --[[position]]  { position = pos },
      --[[collider]]  gear_slot_collider,
      -- --[[collisions]] {},
      --[[sprite]]    gear_slot_sprite,
      },
      untracked_ids
   )

   local position = gear_slot_entity:get_position(storages.position)
   local collider = gear_slot_entity:get_collider(storages.collider)

   collider.entity_id = gear_slot_entity.entity_id
   collider:sync_with_position(position.position)

   return gear_slot_entity
end

global BridgeEntity = #[make_entity(
   'bridge', Bridge,
   'position', Position,
   'collider', Collider,
   'collisions', Collisions,
   'sprite', Sprite
)]#

function BridgeEntity.create(pos: Vector2, slot_idx: uinteger, untracked_ids: vector(GenerationalIndex)*): BridgeEntity
   local bridge_collider: Collider = {
      local_rect = { 0, 0, 32, 32},
      global_rect = { 0, 0, 32, 32},
      entity_id = { -1, 0 },
      entity_tag = EntityTag.ClosedBridge
   }

   local bridge_sprite: Sprite = {
      sprite_sheet = resources.tileset,
      frame_index = 9 + math.random(0 , 1) * 10, -- random: 9 or 19
      frame_rect = { 0, 0, 32, 32 },
      offset = { 0, 0 },
      visible = false,
   }

   local bridge_entity = BridgeEntity.new(
      storages.entity,
      {
      --[[bridge]]     { slot_idx = slot_idx },
      --[[position]]   { position = pos },
      --[[collider]]   bridge_collider,
      --[[collisions]] {},
      --[[sprite]]     bridge_sprite,
      },
      untracked_ids
   )

   local position = bridge_entity:get_position(storages.position)
   local collider = bridge_entity:get_collider(storages.collider)

   collider.entity_id = bridge_entity.entity_id
   collider:sync_with_position(position.position)

   return bridge_entity
end
