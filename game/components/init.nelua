require 'vector'
require 'raylib'
require 'rotor'

-- [ components [
global Player = @record{
   add_something_useful_here_later: cchar,
}

global Gear = @record{
   direction: Vector2,
   engaged: boolean,
}

global GearSlot = @record{
   slot_idx: uinteger
}

global Bridge = @record{
   slot_idx: uinteger
}

global Box = @record{
   add_something_useful_here_later: cchar,
}

global Position = @record{
   position: Vector2
}

global Velocity = @record{
   direction: Vector2,
   speed: number
}

global Collider = @record{
   local_rect: Rectangle,
   global_rect: Rectangle,
   entity_id: GenerationalIndex,
   entity_tag: EntityTag
}

local function get_center(r: Rectangle): Vector2
   return (@Vector2){ r.x + r.width/2, r.y + r.height/2 }
end

function Collider:get_local_center():  Vector2 return get_center(self.local_rect) end
function Collider:get_global_center(): Vector2 return get_center(self.global_rect) end

function Collider:sync_with_position(position: Vector2)
   self.global_rect.x = self.local_rect.x + position.x
   self.global_rect.y = self.local_rect.y + position.y
end

global Intersection = @record{
   collider: Collider,
   rect: Rectangle,
   state: CollisionState
}

function Intersection:get_center(): Vector2 return get_center(self.rect) end

function Intersection:contains_tag(mask: uinteger): boolean return mask & self.collider.entity_tag ~= 0 end

function Intersection:get_direction(point: Vector2, tolerance: number): Vector2
   local difference = point - self.collider:get_global_center()
   return (@Vector2){
      difference.x <= -tolerance and -1 or (difference.x >= tolerance and 1 or 0),
      difference.y <= -tolerance and -1 or (difference.y >= tolerance and 1 or 0)
   }
end

global Collisions = @record{
   intersections: vector(Intersection),
}

global Sprite = @record{
   sprite_sheet: Texture2D,
   frame_index: uinteger,
   frame_rect: Rectangle
}

global AnimationData = @record{
   frame_indexes: vector(uinteger),
   frame_duration: number
}

global Animations = @record{
   animations: vector(AnimationData),
   current_animation_index: uinteger,
   current_frame_index: uinteger,
   elapsed_time: number,
   paused: boolean
}

global Obstacles = @record{
   mask: uinteger -- mask of entitytag
}

function Obstacles:add_obstacle(e_tag: EntityTag) self.mask = self.mask | e_tag end
function Obstacles:remove_obstacle(e_tag: EntityTag) self.mask = self.mask ~ e_tag end
-- ] components ]

-- [ storages [
global storages: record{
   entity: Storage(Entity),
   player: Storage(Player),
   gear: Storage(Gear),
   gear_slot: Storage(GearSlot),
   bridge: Storage(Bridge),
   box: Storage(Box),
   position: Storage(Position),
   velocity: Storage(Velocity),
   collider: Storage(Collider),
   collisions: Storage(Collisions),
   sprite: Storage(Sprite),
   animations: Storage(Animations),
   obstacles: Storage(Obstacles),
} = {
   entity = (@Storage(Entity)).new(),
   player = (@Storage(Player)).new(),
   gear = (@Storage(Gear)).new(),
   gear_slot = (@Storage(GearSlot)).new(),
   bridge = (@Storage(Bridge)).new(),
   box = (@Storage(Box)).new(),
   position = (@Storage(Position)).new(),
   velocity = (@Storage(Velocity)).new(),
   collider = (@Storage(Collider)).new(),
   collisions = (@Storage(Collisions)).new(),
   sprite = (@Storage(Sprite)).new(),
   animations = (@Storage(Animations)).new(),
   obstacles = (@Storage(Obstacles)).new(),
}
-- ] storages ]

-- [ component masks [
global component_masks: record{
   entity: BitsetArray,     --    1
   player: BitsetArray,     --    2
   gear: BitsetArray,       --    4
   gear_slot: BitsetArray,  --    8
   bridge: BitsetArray,     --   16
   box: BitsetArray,        --   32
   position: BitsetArray,   --   64
   velocity: BitsetArray,   --  128
   collider: BitsetArray,   --  256
   collisions: BitsetArray, --  512
   sprite: BitsetArray,     -- 1024
   animations: BitsetArray, -- 2048
   obstacles: BitsetArray,  -- 4096
} = {
   entity = bitset_array.lshift(BITSETARRAY_OF_ONE,     0), --    1
   player = bitset_array.lshift(BITSETARRAY_OF_ONE,     1), --    2
   gear = bitset_array.lshift(BITSETARRAY_OF_ONE,       2), --    4
   gear_slot = bitset_array.lshift(BITSETARRAY_OF_ONE,  3), --    8
   bridge = bitset_array.lshift(BITSETARRAY_OF_ONE,     4), --   16
   box = bitset_array.lshift(BITSETARRAY_OF_ONE,        5), --   32
   position = bitset_array.lshift(BITSETARRAY_OF_ONE,   6), --   64
   velocity = bitset_array.lshift(BITSETARRAY_OF_ONE,   7), --  128
   collider = bitset_array.lshift(BITSETARRAY_OF_ONE,   8), --  256
   collisions = bitset_array.lshift(BITSETARRAY_OF_ONE, 9), --  512
   sprite = bitset_array.lshift(BITSETARRAY_OF_ONE,    10), -- 1024
   animations = bitset_array.lshift(BITSETARRAY_OF_ONE,11), -- 2048
   obstacles = bitset_array.lshift(BITSETARRAY_OF_ONE, 12), -- 4096
}
-- ] component masks ]

-- [ association functions [
function Player.associate(value: Player, entity: Entity*): (GenerationalIndex, Player*)
   local id, ptr = storages.player:new_entry(value)
   entity:associate(id, component_masks.player)
   return id, ptr
end

function Gear.associate(value: Gear, entity: Entity*): (GenerationalIndex, Gear*)
   local id, ptr = storages.gear:new_entry(value)
   entity:associate(id, component_masks.gear)
   return id, ptr
end

function GearSlot.associate(value: GearSlot, entity: Entity*): (GenerationalIndex, GearSlot*)
   local id, ptr = storages.gear_slot:new_entry(value)
   entity:associate(id, component_masks.gear_slot)
   return id, ptr
end

function Bridge.associate(value: Bridge, entity: Entity*): (GenerationalIndex, Bridge*)
   local id, ptr = storages.bridge:new_entry(value)
   entity:associate(id, component_masks.bridge)
   return id, ptr
end

function Box.associate(value: Box, entity: Entity*): (GenerationalIndex, Box*)
   local id, ptr = storages.box:new_entry(value)
   entity:associate(id, component_masks.box)
   return id, ptr
end

function Position.associate(value: Position, entity: Entity*): (GenerationalIndex, Position*)
   local id, ptr = storages.position:new_entry(value)
   entity:associate(id, component_masks.position)
   return id, ptr
end

function Velocity.associate(value: Velocity, entity: Entity*): (GenerationalIndex, Velocity*)
   local id, ptr = storages.velocity:new_entry(value)
   entity:associate(id, component_masks.velocity)
   return id, ptr
end

function Collider.associate(value: Collider, entity: Entity*): (GenerationalIndex, Collider*)
   local id, ptr = storages.collider:new_entry(value)
   entity:associate(id, component_masks.collider)
   return id, ptr
end

function Collisions.associate(value: Collisions, entity: Entity*): (GenerationalIndex, Collisions*)
   local id, ptr = storages.collisions:new_entry(value)
   entity:associate(id, component_masks.collisions)
   return id, ptr
end

function Sprite.associate(value: Sprite, entity: Entity*): (GenerationalIndex, Sprite*)
   local id, ptr = storages.sprite:new_entry(value)
   entity:associate(id, component_masks.sprite)
   return id, ptr
end

function Animations.associate(value: Animations, entity: Entity*): (GenerationalIndex, Animations*)
   local id, ptr = storages.animations:new_entry(value)
   entity:associate(id, component_masks.animations)
   return id, ptr
end

function Obstacles.associate(value: Obstacles, entity: Entity*): (GenerationalIndex, Obstacles*)
   local id, ptr = storages.obstacles:new_entry(value)
   entity:associate(id, component_masks.obstacles)
   return id, ptr
end
-- ] association functions ]
