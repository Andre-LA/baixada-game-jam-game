require 'vector'
require 'raylib'
require 'rotor'

-- [ components [
global Player = @record{
   add_something_useful_here_later: cchar,
}

global Cog = @record{
   direction: Vector2,
   engaged: boolean,
}

global Box = @record{
   minimum_distance: number,
}

global Position = @record{
   position: Vector2
}

global Velocity = @record{
   direction: Vector2,
   speed: number
}

global Collider = @record{
   local_rect: Rectangle,
   global_rect: Rectangle,
   entity_id: GenerationalIndex,
   entity_tag: EntityTag
}

local function get_center(r: Rectangle): Vector2
   return (@Vector2){ r.x + r.width/2, r.y + r.height/2 }
end

function Collider:get_local_center():  Vector2 return get_center(self.local_rect) end
function Collider:get_global_center(): Vector2 return get_center(self.global_rect) end

function Collider:sync_with_position(position: Vector2)
   self.global_rect.x = self.local_rect.x + position.x
   self.global_rect.y = self.local_rect.y + position.y
end

global Intersection = @record{
   collider: Collider,
   rect: Rectangle,
   state: CollisionState
}

function Intersection:get_center(): Vector2 return get_center(self.rect) end

function Intersection:get_direction(point: Vector2, tolerance: number): Vector2
   local difference = point - self.collider:get_global_center()
   return (@Vector2){
      difference.x <= -tolerance and -1 or (difference.x >= tolerance and 1 or 0),
      difference.y <= -tolerance and -1 or (difference.y >= tolerance and 1 or 0)
   }
end

global Collisions = @record{
   intersections: vector(Intersection),
}

global Sprite = @record{
   sprite_sheet: Texture2D,
   frame_index: uinteger,
   frame_rect: Rectangle
}

global AnimationData = @record{
   frame_indexes: vector(uinteger),
   frame_duration: number
}

global Animations = @record{
   animations: vector(AnimationData),
   current_animation_index: uinteger,
   current_frame_index: uinteger,
   elapsed_time: number,
   paused: boolean
}

global Obstacles = @record{
   mask: uinteger -- mask of entitytag
}

function Obstacles:add_obstacle(e_tag: EntityTag) self.mask = self.mask | e_tag end
function Obstacles:remove_obstacle(e_tag: EntityTag) self.mask = self.mask ~ e_tag end
-- ] components ]

-- [ storages [
global storages: record{
   entity: Storage(Entity),
   player: Storage(Player),
   cog: Storage(Cog),
   box: Storage(Box),
   position: Storage(Position),
   velocity: Storage(Velocity),
   collider: Storage(Collider),
   collisions: Storage(Collisions),
   sprite: Storage(Sprite),
   animations: Storage(Animations),
   obstacles: Storage(Obstacles),
} = {
   entity = (@Storage(Entity)).new(),
   player = (@Storage(Player)).new(),
   cog = (@Storage(Cog)).new(),
   box = (@Storage(Box)).new(),
   position = (@Storage(Position)).new(),
   velocity = (@Storage(Velocity)).new(),
   collider = (@Storage(Collider)).new(),
   collisions = (@Storage(Collisions)).new(),
   sprite = (@Storage(Sprite)).new(),
   animations = (@Storage(Animations)).new(),
   obstacles = (@Storage(Obstacles)).new(),
}
-- ] storages ]

-- [ component masks [
global component_masks: record{
   entity: BitsetArray,     --    1
   player: BitsetArray,     --    2
   cog: BitsetArray,        --    4
   box: BitsetArray,        --    8
   position: BitsetArray,   --   16
   velocity: BitsetArray,   --   32
   collider: BitsetArray,   --   64
   collisions: BitsetArray, --  128
   sprite: BitsetArray,     --  256
   animations: BitsetArray, --  512
   obstacles: BitsetArray,  -- 1024
} = {
   entity = bitset_array.lshift(BITSETARRAY_OF_ONE,     0), --    1
   player = bitset_array.lshift(BITSETARRAY_OF_ONE,     1), --    2
   cog = bitset_array.lshift(BITSETARRAY_OF_ONE,        2), --    4
   box = bitset_array.lshift(BITSETARRAY_OF_ONE,        3), --    8
   position = bitset_array.lshift(BITSETARRAY_OF_ONE,   4), --   16
   velocity = bitset_array.lshift(BITSETARRAY_OF_ONE,   5), --   32
   collider = bitset_array.lshift(BITSETARRAY_OF_ONE,   6), --   64
   collisions = bitset_array.lshift(BITSETARRAY_OF_ONE, 7), --  128
   sprite = bitset_array.lshift(BITSETARRAY_OF_ONE,     8), --  256
   animations = bitset_array.lshift(BITSETARRAY_OF_ONE, 9), --  512
   obstacles = bitset_array.lshift(BITSETARRAY_OF_ONE, 10), -- 1024
}
-- ] component masks ]

-- [ association functions [
function Player.associate(value: Player, entity: Entity*): (GenerationalIndex, Player*)
   local id, ptr = storages.player:new_entry(value)
   entity:associate(id, component_masks.player)
   return id, ptr
end

function Cog.associate(value: Cog, entity: Entity*): (GenerationalIndex, Cog*)
   local id, ptr = storages.cog:new_entry(value)
   entity:associate(id, component_masks.cog)
   return id, ptr
end
function Box.associate(value: Box, entity: Entity*): (GenerationalIndex, Box*)
   local id, ptr = storages.box:new_entry(value)
   entity:associate(id, component_masks.box)
   return id, ptr
end
function Position.associate(value: Position, entity: Entity*): (GenerationalIndex, Position*)
   local id, ptr = storages.position:new_entry(value)
   entity:associate(id, component_masks.position)
   return id, ptr
end
function Velocity.associate(value: Velocity, entity: Entity*): (GenerationalIndex, Velocity*)
   local id, ptr = storages.velocity:new_entry(value)
   entity:associate(id, component_masks.velocity)
   return id, ptr
end
function Collider.associate(value: Collider, entity: Entity*): (GenerationalIndex, Collider*)
   local id, ptr = storages.collider:new_entry(value)
   entity:associate(id, component_masks.collider)
   return id, ptr
end
function Collisions.associate(value: Collisions, entity: Entity*): (GenerationalIndex, Collisions*)
   local id, ptr = storages.collisions:new_entry(value)
   entity:associate(id, component_masks.collisions)
   return id, ptr
end
function Sprite.associate(value: Sprite, entity: Entity*): (GenerationalIndex, Sprite*)
   local id, ptr = storages.sprite:new_entry(value)
   entity:associate(id, component_masks.sprite)
   return id, ptr
end
function Animations.associate(value: Animations, entity: Entity*): (GenerationalIndex, Animations*)
   local id, ptr = storages.animations:new_entry(value)
   entity:associate(id, component_masks.animations)
   return id, ptr
end
function Obstacles.associate(value: Obstacles, entity: Entity*): (GenerationalIndex, Obstacles*)
   local id, ptr = storages.obstacles:new_entry(value)
   entity:associate(id, component_masks.obstacles)
   return id, ptr
end

-- ] association functions ]
