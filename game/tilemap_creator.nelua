require 'vector'
require 'game.entities'

global TileKind = @enum{
   None = -1,

   -- values = frame_index of sprite
   WallTL =  0, WallTC =  1, WallTR =  2, -- TL, TC, TR: top-left; top-center; top-right
--[[WallML =  5, WallMC =  6, WallMR =  7, -- ML, MC, MR: middle-left; middle-center; middle-right]]
   WallBL = 10, WallBC = 11, WallBR = 12, -- BL, BC, BR: bottom-left; bottom-center; bottom-right

   WallTop1 = 15, WallTop2 = 16, WallTop3 = 17, WallTop4 = 18,
   WallTop5 = 20, WallTop6 = 21, WallTop7 = 22, WallTop8 = 23, WallTop9 = 24,

   Floor1 = 3, Floor2 = 8, Floor3 = 13,

   Gear = 9,
   Box = 4,

   -- values = 100 + puzzle number
   Bridge1 = 100,
   Bridge2 = 101,
   Bridge3 = 102,

   -- values = 200 + puzzle number
   GearSlot1 = 200,
   GearSlot2 = 201,
   GearSlot3 = 202,
}

global Tile = @record{
   collider_rect: Rectangle,
   offset_mul: integer,
   offset_y: float32,
   kind: TileKind
}

local function is_bridge(kind: TileKind): boolean
   return kind >= TileKind.Bridge1 and kind < 200
end

local function is_gear_slot(kind: TileKind): boolean
   return kind >= TileKind.GearSlot1 and kind < 300
end

local function is_wall(kind: TileKind): boolean
   return kind == TileKind.WallTL or kind == TileKind.WallTC or kind == TileKind.WallTR or
          --kind == TileKind.WallML or kind == TileKind.WallMC or kind == TileKind.WallMR or
          kind == TileKind.WallBL or kind == TileKind.WallBC or kind == TileKind.WallBR or
          kind == TileKind.WallTop1 or kind == TileKind.WallTop2 or kind == TileKind.WallTop3 or
          kind == TileKind.WallTop4 or kind == TileKind.WallTop5 or kind == TileKind.WallTop6 or
          kind == TileKind.WallTop7 or kind == TileKind.WallTop8 or kind == TileKind.WallTop9
end

local function is_floor(kind: TileKind): boolean
   return kind == TileKind.Floor1 or kind == TileKind.Floor2 or kind == TileKind.Floor3
end

local function create_bridge(
   origin: Vector2*,
   i: integer,
   j: integer,
   tile: Tile*,
   untracked_ids: vector(GenerationalIndex)*
)
   local position: Vector2 = { origin.x + 32 * j, (origin.y + 32 * i) - 64}
   BridgeEntity.create(position, tile.kind - 100, untracked_ids)
end

local function create_wall(
   origin: Vector2*,
   i: integer,
   j: integer,
   tile: Tile*,
   untracked_ids: vector(GenerationalIndex)*
)
   local offset_pos: Vector2 = {0, tile.offset_y}
   local position: Vector2 = { origin.x + 32 * j, (origin.y + 32 * i) - 32 }

   WallEntity.create(position + offset_pos, tile.kind, tile.collider_rect, tile.offset_mul, untracked_ids)
end

local function create_gear_slot(
   origin: Vector2,
   i: integer,
   j: integer,
   tile: Tile,
   untracked_ids: vector(GenerationalIndex)*
)
   local position: Vector2 = { origin.x + 32 * j, (origin.y + 32 * i) - 31}
   GearSlotEntity.create(position, tile.kind - 200, untracked_ids)

   tile.kind = TileKind.Floor2
   create_wall(origin, i, j, tile, untracked_ids) -- a wall bottom center
end

local function create_gear(
   origin: Vector2*,
   i: integer,
   j: integer,
   tile: Tile,
   untracked_ids: vector(GenerationalIndex)*
)
   local position: Vector2 = { origin.x + 32 * j, (origin.y + 32 * i) - 32 }
   GearEntity.create(position, untracked_ids)

   tile.kind = TileKind.Floor2
   create_wall(origin, i, j, tile, untracked_ids) -- a floor
end

local function create_box(
   origin: Vector2*,
   i: integer,
   j: integer,
   tile: Tile,
   untracked_ids: vector(GenerationalIndex)*
)
   local position: Vector2 = { origin.x + 32 * j, (origin.y + 32 * i) - 32 }
   BoxEntity.create(position, untracked_ids)

   tile.kind = TileKind.Floor2
   create_wall(origin, i, j, tile, untracked_ids) -- a floor
end

global function create_tiles(
   origin: Vector2,
   tilemap: vector(vector(Tile))*,
   untracked_ids: vector(GenerationalIndex)*
)
   for i = 0, < #tilemap do
      local tile_line = tilemap[i]

      for j = 0, < #tile_line do
         local tile: Tile* = tile_line[j]
         if is_bridge(tile.kind) then
            create_bridge(origin, i, j, tile, untracked_ids)
         elseif tile.kind == TileKind.Gear then
            create_gear(origin, i, j, tile, untracked_ids)
         elseif tile.kind == TileKind.Box then
            create_box(origin, i, j, tile, untracked_ids)
         elseif is_gear_slot(tile.kind) then
            create_gear_slot(origin, i, j, tile, untracked_ids)
         elseif is_wall(tile.kind) then
            create_wall(origin, i, j, tile, untracked_ids)
         elseif is_floor(tile.kind) then
            create_wall(origin, i, j, tile, untracked_ids)
         end
      end
   end
end
